<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Epic generation & list of user stories</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"/>
  <style>
    /* Modern CSS Variables for Design System */
    :root {
      --primary-red: #d0021b;
      --primary-red-dark: #a0011a;
      --primary-red-light: #ff1744;
      --primary-red-lighter: #fff5f5;
      --background-dark: #1a1d23;
      --background-darker: #121419;
      --background-light: #2a2d35;
      --surface-primary: #ffffff;
      --surface-secondary: #f8fafc;
      --surface-tertiary: #f1f5f9;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --text-light: #ffffff;
      --text-muted: #94a3b8;
      --border-light: #e2e8f0;
      --border-medium: #cbd5e1;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
      --radius-sm: 0.375rem;
      --radius-md: 0.5rem;
      --radius-lg: 0.75rem;
      --radius-xl: 1rem;
      --spacing-xs: 0.5rem;
      --spacing-sm: 0.75rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      --spacing-2xl: 3rem;
    }

    /* Modern Body Styling with Gradient */
    body {
      background: linear-gradient(135deg, var(--background-darker) 0%, var(--background-dark) 100%);
      color: var(--text-light);
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 20% 80%, rgba(208, 2, 27, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(59, 130, 246, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    /* Enhanced Header Bar */
    .header-bar {
      background: linear-gradient(135deg, var(--primary-red) 0%, var(--primary-red-dark) 100%);
      color: white;
      text-align: center;
      font-weight: 700;
      font-size: 1.5rem;
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-xl) var(--radius-xl) var(--radius-lg) var(--radius-lg);
      margin-bottom: var(--spacing-xl);
      box-shadow: var(--shadow-lg);
      position: relative;
      overflow: hidden;
    }

    .header-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    /* Modern Section Headers */
    .section-header {
      background: linear-gradient(135deg, var(--background-light) 0%, #3a3d47 100%);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-lg);
      font-weight: 600;
      font-size: 1.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: var(--spacing-2xl);
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
    }

    .section-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-red), var(--primary-red-light));
      border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    }

    /* Enhanced Card Styling */
    .epic-card, .user-story-card {
      background: var(--surface-primary);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      margin-bottom: var(--spacing-lg);
      color: var(--text-primary);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-light);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      animation: cardSlideIn 0.6s ease-out forwards;
      opacity: 0;
      transform: translateY(20px);
    }

    .epic-card:nth-child(n) {
      animation-delay: calc(0.1s * var(--i, 0));
    }

    @keyframes cardSlideIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .epic-card:hover, .user-story-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-xl);
      border-color: var(--primary-red);
    }

    .epic-card::before, .user-story-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-red), var(--primary-red-light));
      transform: scaleX(0);
      transition: transform 0.3s ease;
      transform-origin: left;
    }

    .epic-card:hover::before, .user-story-card:hover::before {
      transform: scaleX(1);
    }

    /* Container Enhancements */
    #epics-container, #user-stories-container {
      background: var(--surface-primary);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      margin-top: var(--spacing-lg);
      color: var(--text-primary);
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border-light);
      position: relative;
    }

    /* Typography Improvements */
    .epic-card h5 {
      color: var(--primary-red);
      font-weight: 700;
      font-size: 1.2rem;
      margin-bottom: var(--spacing-sm);
      line-height: 1.4;
    }

    .epic-card p {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 0;
    }

    /* Enhanced Priority Styling */
    .priority-high {
      color: #ef4444;
      font-weight: 600;
      background: #fef2f2;
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
      border: 1px solid #fecaca;
    }
    .priority-medium {
      color: #f59e0b;
      font-weight: 600;
      background: #fffbeb;
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
      border: 1px solid #fed7aa;
    }
    .priority-low {
      color: #10b981;
      font-weight: 600;
      background: #f0fdf4;
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
      border: 1px solid #bbf7d0;
    }
    /* Modern Footer Button Styling */
    .footer-btn {
      background: linear-gradient(135deg, var(--primary-red) 0%, var(--primary-red-dark) 100%);
      color: white;
      font-weight: 600;
      font-size: 1.1rem;
      padding: var(--spacing-lg) var(--spacing-xl);
      width: 100%;
      border-radius: var(--radius-lg);
      border: none;
      margin-top: var(--spacing-2xl);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      box-shadow: var(--shadow-lg);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      min-height: 60px;
    }

    .footer-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }

    .footer-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-xl);
      background: linear-gradient(135deg, var(--primary-red-light) 0%, var(--primary-red) 100%);
    }

    .footer-btn:hover:not(:disabled)::before {
      left: 100%;
    }

    .footer-btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .footer-btn:disabled {
      background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
      cursor: not-allowed;
      transform: none;
      box-shadow: var(--shadow-md);
    }

    .footer-btn .btn-spinner {
      width: 1.25rem;
      height: 1.25rem;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    .footer-btn .btn-timer {
      font-size: 0.9rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      background: rgba(255, 255, 255, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Enhanced Utility Classes */
    .hidden {
      display: none !important;
    }
    
    /* Modern Table Styling */
    .table {
      background-color: var(--surface-primary);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-light);
    }
    
    .table th {
      background: linear-gradient(135deg, var(--text-primary) 0%, #374151 100%);
      color: white;
      border: none;
      font-weight: 600;
      font-size: 0.95rem;
      vertical-align: middle;
      padding: var(--spacing-lg);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .table td {
      vertical-align: middle;
      border-color: var(--border-light);
      padding: var(--spacing-lg);
      color: var(--text-primary);
      font-weight: 500;
    }
    
    .table-striped tbody tr:nth-of-type(odd) {
      background-color: var(--surface-secondary);
    }
    
    .table tbody tr {
      transition: all 0.2s ease;
    }
    
    .table tbody tr:hover {
      background-color: var(--primary-red-lighter) !important;
      transform: scale(1.01);
      box-shadow: var(--shadow-sm);
    }
    
    /* Enhanced Badge Styling */
    .badge {
      font-size: 0.8rem;
      font-weight: 600;
      padding: 0.4rem 0.8rem;
      border-radius: var(--radius-md);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .badge-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);
    }
    
    .badge-warning {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      box-shadow: 0 2px 4px rgba(245, 158, 11, 0.2);
    }
    
    .badge-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
    }
    
    .badge-secondary {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      color: white;
      box-shadow: 0 2px 4px rgba(107, 114, 128, 0.2);
    }
    
    /* Enhanced Form Controls */
    .form-check-input:checked {
      background-color: var(--primary-red);
      border-color: var(--primary-red);
      box-shadow: 0 0 0 3px rgba(208, 2, 27, 0.2);
    }
    
    .form-check-input {
      border-radius: var(--radius-sm);
      border: 2px solid var(--border-medium);
      transition: all 0.2s ease;
    }
    
    .form-check-input:focus {
      box-shadow: 0 0 0 3px rgba(208, 2, 27, 0.2);
    }
    
    /* Enhanced Chat Button Styles */
    .chat-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    
    .chat-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .chat-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%);
      color: white;
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: var(--shadow-md);
    }
    
    .chat-btn:hover::before {
      left: 100%;
    }
    
    .chat-btn:active {
      transform: translateY(0);
    }
    
    .chat-btn span:first-child {
      font-size: 1rem;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }

    /* Instruction Text Styling */
    .instruction-text {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      margin-bottom: var(--spacing-xl) !important;
      font-size: 1rem;
      line-height: 1.6;
      backdrop-filter: blur(10px);
    }

    .instruction-text strong {
      color: var(--primary-red-light);
      font-weight: 700;
    }

    /* Container Layout Improvements */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--spacing-lg);
    }

    /* Epic Card Checkbox Enhancement */
    .epic-card .form-check {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
    }

    .epic-card .form-check-input {
      width: 1.2rem;
      height: 1.2rem;
      margin: 0;
    }

    .epic-card .form-check-label {
      margin: 0;
      font-weight: 600;
      cursor: pointer;
    }

    /* Progress and Loading States */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }

    .loading-spinner {
      width: 3rem;
      height: 3rem;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid var(--primary-red);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Status Messages */
    .status-message {
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .status-success {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border: 1px solid #86efac;
    }

    .status-error {
      background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
      color: #991b1b;
      border: 1px solid #fca5a5;
    }

    .status-warning {
      background: linear-gradient(135deg, #fffbeb 0%, #fed7aa 100%);
      color: #92400e;
      border: 1px solid #fdba74;
    }

    /* Enhanced Responsive Design */
    @media (max-width: 1200px) {
      .container {
        max-width: 100%;
        padding: 0 var(--spacing-md);
      }
    }

    @media (max-width: 768px) {
      :root {
        --spacing-xl: 1.5rem;
        --spacing-2xl: 2rem;
      }

      .header-bar {
        font-size: 1.25rem;
        padding: var(--spacing-md) var(--spacing-lg);
        margin-bottom: var(--spacing-lg);
      }

      .section-header {
        flex-direction: column;
        gap: var(--spacing-md);
        padding: var(--spacing-md);
        text-align: center;
      }

      .chat-btn {
        width: 100%;
        justify-content: center;
        padding: var(--spacing-md);
      }

      .epic-card, .user-story-card {
        padding: var(--spacing-lg);
        margin-bottom: var(--spacing-md);
      }

      .table-responsive {
        font-size: 0.875rem;
      }

      .table th, .table td {
        padding: var(--spacing-sm);
      }

      .footer-btn {
        font-size: 1rem;
        padding: var(--spacing-md) var(--spacing-lg);
        min-height: 50px;
      }

      .instruction-text {
        font-size: 0.9rem;
        padding: var(--spacing-md);
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 0 var(--spacing-sm);
      }

      .header-bar {
        font-size: 1.1rem;
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .section-header {
        padding: var(--spacing-sm);
        font-size: 1.1rem;
      }

      .epic-card, .user-story-card {
        padding: var(--spacing-md);
      }

      .epic-card h5 {
        font-size: 1.1rem;
      }

      .chat-btn {
        font-size: 0.8rem;
        padding: var(--spacing-sm);
      }

      .table {
        font-size: 0.8rem;
      }

      .badge {
        font-size: 0.7rem;
        padding: 0.3rem 0.6rem;
      }
    }

    /* Print Styles */
    @media print {
      body {
        background: white !important;
        color: black !important;
      }

      .chat-btn {
        display: none !important;
      }

      .footer-btn {
        display: none !important;
      }

      .section-header {
        background: #f8f9fa !important;
        color: black !important;
      }
    }
    
    /* Chat Modal Styles - Right Side Full Height */
    .chat-modal {
      display: none !important;
      position: fixed !important;
      z-index: 99999 !important;
      right: 0px !important;
      top: 0px !important;
      width: 600px !important;
      height: 100vh !important;
      background-color: rgba(0, 0, 0, 0.1) !important;
      backdrop-filter: blur(2px);
    }
    
    .chat-modal[style*="display: block"] {
      display: block !important;
    }
    
    .chat-modal-content {
      background-color: white;
      margin: 0;
      padding: 0;
      border: none;
      border-radius: 12px 0 0 12px;
      width: 100%;
      height: 100%;
      box-shadow: -8px 0 32px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      border-left: 1px solid #e2e8f0;
    }
    
    .chat-header {
      background-color: #d0021b;
      color: white;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 16px;
    }
    
    .chat-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chat-clear-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 16px;
      cursor: pointer;
      padding: 8px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
      font-weight: normal;
    }
    
    .chat-clear-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    
    .chat-clear-btn:active {
      transform: scale(0.95);
    }
    
    .chat-close {
      background: none;
      border: none;
      color: white;
      font-size: 28px;
      cursor: pointer;
      padding: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
      font-weight: normal;
    }
    
    .chat-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    
    .chat-messages {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
      background: #f8f9fa;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    
    .chat-message {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      max-width: 80%;
    }
    
    .chat-message.user {
      align-self: flex-end;
      flex-direction: row-reverse;
    }
    
    .chat-message.assistant {
      align-self: flex-start;
    }
    
    .chat-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      flex-shrink: 0;
    }
    
    .chat-avatar.user {
      background: #d0021b;
      color: white;
    }
    
    .chat-avatar.assistant {
      background: #f8f9fa;
      color: #8B4513;
      border: 2px solid #007bff;
    }
    
    .chat-bubble {
      background: rgb(224, 224, 235);
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
      word-wrap: break-word;
      line-height: 1.5;
      color: #8B4513;
    }
    
    .chat-message.user .chat-bubble {
      background: #d0021b;
      color: white;
      border-color: #d0021b;
    }
    
    .chat-input-area {
      padding: 24px;
      background: white;
      border-top: 1px solid #e2e8f0;
      display: flex;
      gap: 16px;
      align-items: flex-end;
    }
    
    .chat-input {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 14px;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      font-family: inherit;
    }
    
    .chat-input:focus {
      outline: none;
      border-color: #d0021b;
      box-shadow: 0 0 0 2px rgba(208, 2, 27, 0.1);
    }
    
    .chat-send-btn {
      background: #d0021b;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      height: 44px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chat-send-btn:hover:not(:disabled) {
      background: #a0011a;
      transform: translateY(-1px);
    }
    
    .chat-send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    .chat-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #666;
      font-style: italic;
    }
    
    .chat-loading-dots {
      display: inline-block;
    }
    
    .chat-loading-dots::after {
      content: '';
      animation: chatLoading 1.5s infinite;
    }
    
    @keyframes chatLoading {
      0%, 33% { content: '.'; }
      34%, 66% { content: '..'; }
      67%, 100% { content: '...'; }
    }
    
    .current-description {
      background: #fff5f5;
      border: 1px solid #fed7d7;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 24px;
    }
    
    .current-description h6 {
      color: #d0021b;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .current-description-text {
      color: #333;
      line-height: 1.6;
      margin: 0;
    }
    
    /* Responsive Chat Modal */
    @media (max-width: 768px) {
      .chat-modal {
        right: 0px !important;
        top: 0px !important;
        width: 100vw !important;
        height: 100vh !important;
        background-color: rgba(0, 0, 0, 0.3) !important;
      }
      
      .chat-modal-content {
        border-radius: 0;
        box-shadow: none;
        border: none;
      }
      
      .chat-message {
        max-width: 90%;
      }
      
      .chat-input-area {
        padding: 12px;
      }
      
      .chat-input {
        font-size: 13px;
        padding: 8px 12px;
      }
      
      .chat-send-btn {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .chat-btn {
        font-size: 10px;
        padding: 6px 12px;
        gap: 4px;
      }
    }
    
    @media (max-width: 480px) {
      .chat-modal {
        right: 0px !important;
        top: 0px !important;
        width: 100vw !important;
        height: 100vh !important;
        background-color: rgba(0, 0, 0, 0.5) !important;
      }
      
      .chat-header {
        padding: 12px 16px;
        font-size: 14px;
      }
      
      .chat-clear-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }
      
      .chat-close {
        width: 32px;
        height: 32px;
        font-size: 24px;
      }
      
      .chat-messages {
        padding: 15px;
        gap: 12px;
      }
      
      .chat-avatar {
        width: 30px;
        height: 30px;
        font-size: 14px;
      }
      
      .chat-bubble {
        padding: 10px 12px;
        font-size: 13px;
      }
    }

    /* Main Wrapper */
    .main-wrapper {
      min-height: 100vh;
      padding: var(--spacing-lg) 0;
    }
    
   </style>
</head>
<body>
<div class="main-wrapper">
  <div class="container mt-4">
    <div class="header-bar">Epic generation & list of user stories</div>
  
  <div class="section-header">
    <span>Epics</span>
    <button class="chat-btn" onclick="openEpicChat()">
      <span>üí¨</span>
      Epic Chat
    </button>
   </div>
  
  <div id="epics-container">
    {{ epics|safe }}
  </div>
  
  <form id="approve-epics-form" method="POST" action="/approve-epics">
    <input type="hidden" name="epic_ids" id="epic_ids" value="epic_1,epic_2">
    <button type="submit" class="footer-btn" id="approveEpicsBtn">
      <span class="btn-spinner" id="approveSpinner"></span>
      <span class="btn-text">Approve Epic(s)</span>
      <span class="btn-timer" id="approveTimer"></span>
    </button>
  </form>

  <div id="user-stories-section" class="{{ 'hidden' if not user_stories }}">
    <div class="section-header">
      <span>User stories</span>
      <button class="chat-btn" onclick="openUserStoryChat()">
        <span>üí¨</span>
        User Story Chat
      </button>
     </div>
    <p class="mb-3 text-light instruction-text">
      Review this list of generated user stories for each epic, sorted by the solution's ranking of priority based on industry and uploaded context. Select <strong>one</strong> story to proceed with generating a detailed user story.
    </p>
    <form id="proceed-form" method="POST" action="/user-story-details">
      <div id="user-stories-container">
        {{ user_stories|safe }}
      </div>    
      <input type="hidden" name="selected_story_id" id="selected_story_id">
      <input type="hidden" name="selected_story_name" id="selected_story_name">
      <input type="hidden" name="selected_story_description" id="selected_story_description">
      <input type="hidden" name="selected_story_priority" id="selected_story_priority">
      <input type="hidden" name="selected_story_systems" id="selected_story_systems">
      <input type="hidden" name="epic_title" id="selected_epic_title">
      <button type="submit" class="footer-btn" id="proceedBtn">
        <span class="btn-spinner" id="proceedSpinner"></span>
        <span class="btn-text">Proceed To Selection</span>
        <span class="btn-timer" id="proceedTimer"></span>
      </button>
    </form>
  </div>
</div>
</div>

<!-- Epic Chat Modal -->
<div id="epic-chat-modal" class="chat-modal">
  <div class="chat-modal-content">
    <div class="chat-header">
      <span>üí¨ Epic Chat</span>
      <div class="chat-header-actions">
        <button class="chat-clear-btn" onclick="clearEpicChat()" title="Clear Chat History">
          <span>üóëÔ∏è</span>
        </button>
        <button class="chat-close" onclick="closeEpicChat()">&times;</button>
      </div>
    </div>
    <div class="chat-container">
      <!-- Current Epic Context Display -->
      <div class="current-description">
        <h6>Current Epic Context:</h6>
        <p class="current-description-text" id="current-epic-display">Chat about the currently selected or visible epics. I can help you refine, modify, or generate new epics.</p>
      </div>
      
      <!-- Chat Messages -->
      <div class="chat-messages" id="epic-chat-messages">
        <div class="chat-message assistant">
          <div class="chat-avatar assistant">AI</div>
          <div class="chat-bubble">
            Hello! I'm here to help you with your epics. I can:
            <br>‚Ä¢ Refine existing epic descriptions
            <br>‚Ä¢ Generate new epics based on your requirements
            <br>‚Ä¢ Improve epic titles and details
            <br>‚Ä¢ Suggest epic priorities and breakdowns
            <br><br>What would you like to work on with your epics?
          </div>
        </div>
      </div>
      
      <!-- Chat Input -->
      <div class="chat-input-area">
        <textarea id="epic-chat-input" class="chat-input" placeholder="Ask me about epics..." rows="1"></textarea>
        <button class="chat-send-btn" onclick="sendEpicMessage()" id="epic-send-btn">
          <span>üì§</span>
          Send
        </button>
      </div>
    </div>
  </div>
</div>

<!-- User Story Chat Modal -->
<div id="user-story-chat-modal" class="chat-modal">
  <div class="chat-modal-content">
    <div class="chat-header">
      <span>üí¨ User Story Chat</span>
      <div class="chat-header-actions">
        <button class="chat-clear-btn" onclick="clearUserStoryChat()" title="Clear Chat History">
          <span>üóëÔ∏è</span>
        </button>
        <button class="chat-close" onclick="closeUserStoryChat()">&times;</button>
      </div>
    </div>
    <div class="chat-container">
      <!-- Current User Story Context Display -->
      <div class="current-description">
        <h6>Current User Story Context:</h6>
        <p class="current-description-text" id="current-user-story-display">Chat about the currently displayed user stories. I can help you refine, prioritize, or generate new user stories.</p>
      </div>
      
      <!-- Chat Messages -->
      <div class="chat-messages" id="user-story-chat-messages">
        <div class="chat-message assistant">
          <div class="chat-avatar assistant">AI</div>
          <div class="chat-bubble">
            Hello! I'm here to help you with your user stories. I can:
            <br>‚Ä¢ Refine existing user story details
            <br>‚Ä¢ Generate additional user stories
            <br>‚Ä¢ Improve user story priorities and descriptions
            <br>‚Ä¢ Suggest better acceptance criteria
            <br><br>What would you like to work on with your user stories?
          </div>
        </div>
      </div>
      
      <!-- Chat Input -->
      <div class="chat-input-area">
        <textarea id="user-story-chat-input" class="chat-input" placeholder="Ask me about user stories..." rows="1"></textarea>
        <button class="chat-send-btn" onclick="sendUserStoryMessage()" id="user-story-send-btn">
          <span>üì§</span>
          Send
        </button>
      </div>
    </div>
  </div>
</div>

<script>  
  // Timer and spinner utility functions
  let approveTimer = null;
  let proceedTimer = null;

  function startTimer(timerId, buttonTimerElement) {
    if (!buttonTimerElement) {
      console.error('startTimer: buttonTimerElement is null');
      return null;
    }
    
    let seconds = 0;
    return setInterval(() => {
      seconds++;
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      const timeString = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
      buttonTimerElement.textContent = timeString;
    }, 1000);
  }

  function showButtonLoading(button, spinner, timer, buttonText, loadingText) {
    if (!button) {
      console.error('showButtonLoading: button element is null');
      return null;
    }

    try {
      button.disabled = true;
      
      // Show spinner if available
      if (spinner) {
        spinner.style.display = 'block';
      } else {
        console.warn('showButtonLoading: spinner element not found');
      }
      
      // Update button text if available
      const btnTextElement = button.querySelector('.btn-text');
      if (btnTextElement) {
        btnTextElement.textContent = loadingText;
      } else {
        console.warn('showButtonLoading: .btn-text element not found');
      }
      
      // Start timer if available
      if (timer) {
        timer.textContent = '0:00';
        const intervalId = startTimer(null, timer);
        if (intervalId) {
          return intervalId;
        } else {
          console.warn('showButtonLoading: failed to start timer, creating fallback');
          // Fallback timer implementation
          let seconds = 0;
          return setInterval(() => {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const timeString = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            if (timer) timer.textContent = timeString;
          }, 1000);
        }
      } else {
        console.warn('showButtonLoading: timer element not found');
        return null;
      }
    } catch (error) {
      console.error('Error in showButtonLoading:', error);
      return null;
    }
  }

  function hideButtonLoading(button, spinner, timer, originalText, timerInterval) {
    if (!button) {
      console.warn('hideButtonLoading: button element is null');
      return;
    }

    try {
      button.disabled = false;
      
      // Hide spinner if available
      if (spinner) {
        spinner.style.display = 'none';
      } else {
        console.warn('hideButtonLoading: spinner element not found');
      }
      
      // Restore button text if available
      const btnTextElement = button.querySelector('.btn-text');
      if (btnTextElement) {
        btnTextElement.textContent = originalText;
      } else {
        console.warn('hideButtonLoading: .btn-text element not found');
      }
      
      // Clear timer if available
      if (timer) {
        timer.textContent = '';
      } else {
        console.warn('hideButtonLoading: timer element not found');
      }
      
      // Clear timer interval
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    } catch (error) {
      console.error('Error in hideButtonLoading:', error);
    }
  }

  // Function to parse and format epics if they're in JSON format
  function parseAndFormatEpics() {
    const epicsContainer = document.getElementById('epics-container');
    let content = epicsContainer.innerHTML.trim();
    
    // If content is already formatted (contains epic-card divs), don't reprocess
    if (content.includes('epic-card')) {
      return;
    }
    
    // Remove any HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    content = tempDiv.textContent || tempDiv.innerText || '';
    content = content.trim();
    
    // If content is empty or very short, leave it as is
    if (!content || content.length < 5) {
      return;
    }
    
    try {
      // Clean up the content - remove any backticks or markdown formatting
      let cleanContent = content;
      if (cleanContent.startsWith('```json')) {
        cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/\s*```\s*$/, '');
      }
      if (cleanContent.startsWith('```')) {
        cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```\s*$/, '');
      }
      
      // Try to parse as JSON
      const epicsData = JSON.parse(cleanContent);
      
      if (Array.isArray(epicsData)) {
        // Format the epics nicely
        let formattedHTML = '';
        epicsData.forEach((epic, index) => {
          const epicTitle = epic.epic_title || epic.title || `Untitled Epic ${index + 1}`;
          const epicDescription = epic.epic_description || epic.description || 'No description available.';
          formattedHTML += `
            <div class="epic-card">
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" name="epic_ids" value="epic_${index + 1}" id="epic_${index + 1}">
                <h5 style="margin: 0;">Epic ${index + 1}: ${epicTitle}</h5>
              </div>
              <p><strong>Description:</strong> ${epicDescription}</p>
            </div>
          `;
        });
        
        epicsContainer.innerHTML = formattedHTML;
        return;
      } else if (epicsData && typeof epicsData === 'object') {
        // Handle single epic object
        const epicTitle = epicsData.epic_title || epicsData.title || 'Untitled Epic';
        const epicDescription = epicsData.epic_description || epicsData.description || 'No description available.';
        const formattedHTML = `
          <div class="epic-card">
            <div style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" name="epic_ids" value="epic_1" id="epic_1">
              <h5 style="margin: 0;">Epic 1: ${epicTitle}</h5>
            </div>
            <p><strong>Description:</strong> ${epicDescription}</p>
          </div>
        `;
        epicsContainer.innerHTML = formattedHTML;
        return;
      }
    } catch (e) {
      // Try to extract JSON from text that might have extra content
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        try {
          const epicsData = JSON.parse(jsonMatch[0]);
          if (Array.isArray(epicsData)) {
            let formattedHTML = '';
            epicsData.forEach((epic, index) => {
              const epicTitle = epic.epic_title || epic.title || `Untitled Epic ${index + 1}`;
              const epicDescription = epic.epic_description || epic.description || 'No description available.';
              formattedHTML += `
                <div class="epic-card">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" name="epic_ids" value="epic_${index + 1}" id="epic_${index + 1}">
                    <h5 style="margin: 0;">Epic ${index + 1}: ${epicTitle}</h5>
                  </div>
                  <p><strong>Description:</strong> ${epicDescription}</p>
                </div>
              `;
            });
            epicsContainer.innerHTML = formattedHTML;
            return;
          }
        } catch (e2) {
          // If all parsing fails, leave content as is
        }
      }
    }
  }

  // Function to set up event listeners for user story checkboxes
  function setupUserStoryCheckboxListeners() {
    console.log('Setting up user story checkbox event listeners');
    
    // Get all user story checkboxes
    const checkboxes = document.querySelectorAll('input[name="user_story_ids"]');
    console.log(`Found ${checkboxes.length} user story checkboxes`);
    
    checkboxes.forEach((checkbox, index) => {
      checkbox.addEventListener('change', function() {
        console.log(`Checkbox ${index} changed, checked: ${this.checked}`);
        
        if (this.checked) {
          // Uncheck other checkboxes (single selection)
          checkboxes.forEach(cb => {
            if (cb !== this) cb.checked = false;
          });
          
          // Update hidden form fields
          const storyId = this.value;
          const storyName = this.getAttribute('data-name');
          const storyDescription = this.getAttribute('data-description');
          const storyPriority = this.getAttribute('data-priority');
          const storySystems = this.getAttribute('data-systems');
          
          console.log('Updating hidden form fields with:', {
            id: storyId,
            name: storyName,
            description: storyDescription ? storyDescription.substring(0, 50) + '...' : 'N/A',
            priority: storyPriority,
            systems: storySystems
          });
          
          // Set hidden form field values
          const storyIdField = document.getElementById('selected_story_id');
          const storyNameField = document.getElementById('selected_story_name');
          const storyDescField = document.getElementById('selected_story_description');
          const storyPriorityField = document.getElementById('selected_story_priority');
          const storySystemsField = document.getElementById('selected_story_systems');
          const epicTitleField = document.getElementById('selected_epic_title');
          
          if (storyIdField) storyIdField.value = storyId || '';
          if (storyNameField) storyNameField.value = storyName || '';
          if (storyDescField) storyDescField.value = storyDescription || '';
          if (storyPriorityField) storyPriorityField.value = storyPriority || 'Medium';
          if (storySystemsField) storySystemsField.value = storySystems || '';
          
          // Populate epic title from the currently selected/visible epic
          if (epicTitleField) {
            // Try to get epic title from the currently selected epic
            const selectedEpicCheckbox = document.querySelector('input[name="epic_ids"]:checked');
            let epicTitle = '';
            
            if (selectedEpicCheckbox) {
              const epicCard = selectedEpicCheckbox.closest('.epic-card');
              if (epicCard) {
                const titleElement = epicCard.querySelector('h5');
                if (titleElement) {
                  epicTitle = titleElement.textContent.replace(/^Epic \d+: /, '').trim();
                }
              }
            }
            
            // Fallback: try to get from first epic if none selected
            if (!epicTitle) {
              const firstEpicCard = document.querySelector('.epic-card');
              if (firstEpicCard) {
                const titleElement = firstEpicCard.querySelector('h5');
                if (titleElement) {
                  epicTitle = titleElement.textContent.replace(/^Epic \d+: /, '').trim();
                }
              }
            }
               // Final fallback: extract from epic container text content
            if (!epicTitle) {
              const epicsContainer = document.getElementById('epics-container');
              if (epicsContainer) {
                const epicText = epicsContainer.textContent || '';
                // Try to extract epic title from text content
                const epicMatch = epicText.match(/Epic \d+:\s*([^Description\n]+)/);
                if (epicMatch && epicMatch[1]) {
                  epicTitle = epicMatch[1].trim();
                }
              }
            }
            epicTitleField.value = epicTitle || 'User Story Epic';
            console.log('Epic title set to:', epicTitle);
          }
          
          console.log('Hidden form fields updated successfully');
        }
      });
    });
    
    console.log('User story checkbox event listeners set up successfully');
  }

  // Function to parse and format user stories if they're in JSON format
  function parseAndFormatUserStories() {
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (!userStoriesContainer) {
      return;
    }
    
    let content = userStoriesContainer.innerHTML.trim();
    
    // If content is already formatted (contains user-story-card or table), don't reprocess
    if (content.includes('user-story-card') || content.includes('<table')) {
      return;
    }
    
    // Remove any HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    content = tempDiv.textContent || tempDiv.innerText || '';
    content = content.trim();
    
    // If content is empty or very short, leave it as is
    if (!content || content.length < 5) {
      return;
    }

    try {
      // Multiple strategies to extract JSON from text
      let cleanContent = content;
      let extractionMethod = 'direct';
      
      // Strategy 1: Look for markdown-wrapped JSON
      if (cleanContent.includes('```json')) {
        const jsonMatch = cleanContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          cleanContent = jsonMatch[1].trim();
          extractionMethod = 'markdown-json';
        }
      } 
      // Strategy 2: Look for any code block with ````
      else if (cleanContent.includes('```')) {
        const codeBlockMatch = cleanContent.match(/```\s*([\s\S]*?)\s*```/);
        if (codeBlockMatch && codeBlockMatch[1]) {
          cleanContent = codeBlockMatch[1].trim();
          extractionMethod = 'markdown-code';
        }
      }
      
      // Strategy 3: Look for JSON array pattern (most robust)
      const jsonArrayPattern = /\[\s*\{[\s\S]*?\}\s*(?:,\s*\{[\s\S]*?\}\s*)*\]/;
      const jsonArrayMatch = cleanContent.match(jsonArrayPattern);
      if (jsonArrayMatch) {
        cleanContent = jsonArrayMatch[0];
        extractionMethod = 'regex-array';
      }
      
      console.log(`User stories extraction method: ${extractionMethod}`);
      
      // Try to parse as JSON
      const userStoriesData = JSON.parse(cleanContent);
      
      if (Array.isArray(userStoriesData) && userStoriesData.length > 0) {
        console.log('Successfully parsed user stories array:', userStoriesData);
        
        // Format the user stories as a table
        let formattedHTML = `
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead class="thead-dark">
                <tr>
                  <th>Select</th>
                  <th>Story ID</th>
                  <th>Name</th>
                  <th>Priority</th>
                  <th>Systems</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        userStoriesData.forEach((story, index) => {
          // Handle the new agent response format
          const storyId = story.story_id || `US-${index + 1}`;
          const storyName = story.name || story.title || 'Untitled Story';
          const storyPriority = story.priority || 'Medium';
          const storySystems = Array.isArray(story.systems) ? story.systems.join(', ') : (story.systems || 'TBD');
          
          // Use the story name as description if no separate description field
          const storyDescription = story.description || story.name || 'No description available';
          
          // Escape HTML for data attributes to prevent attribute breaking
          const escapedName = storyName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
          const escapedDescription = storyDescription.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
          
          // Determine priority badge color
          let priorityClass = 'badge-secondary';
          if (storyPriority.toLowerCase() === 'high') {
            priorityClass = 'badge-danger';
          } else if (storyPriority.toLowerCase() === 'medium') {
            priorityClass = 'badge-warning';
          } else if (storyPriority.toLowerCase() === 'low') {
            priorityClass = 'badge-success';
          }
          
          formattedHTML += `
            <tr>
              <td>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" name="user_story_ids" 
                  value="${storyId}" id="story_${index + 1}"
                  data-name="${escapedName}" 
                  data-description="${escapedDescription}"
                  data-priority="${storyPriority}"
                  data-systems="${storySystems}"${index === 0 ? ' checked' : ''}>
                  <label class="form-check-label" for="story_${index + 1}"></label>
                </div>
              </td>
              <td><strong>${storyId}</strong></td>
              <td><strong>${storyName}</strong></td>
              <td><span class="badge ${priorityClass}">${storyPriority}</span></td>
              <td>${storySystems}</td>
            </tr>
          `;
        });
        
        formattedHTML += `
              </tbody>
            </table>
          </div>
        `;
        
        userStoriesContainer.innerHTML = formattedHTML;
        console.log('User stories formatted successfully as table');
        
        // Add event listeners to checkboxes to update hidden form fields
        setupUserStoryCheckboxListeners();
        
        // Trigger change event on the first checkbox to populate hidden fields
        setTimeout(() => {
          const firstCheckbox = document.querySelector('input[name="user_story_ids"]:checked');
          if (firstCheckbox) {
            console.log('Triggering change event on first checkbox');
            firstCheckbox.dispatchEvent(new Event('change'));
          }
        }, 100);
        
        // Show the user stories section
        const userStoriesSection = document.getElementById('user-stories-section');
        if (userStoriesSection) {
          userStoriesSection.classList.remove('hidden');
        }
        
        return;
      } else if (userStoriesData && typeof userStoriesData === 'object') {
        // Handle single user story object
        console.log('Single user story object detected');
        
        const storyName = userStoriesData.name || userStoriesData.title || 'Untitled Story';
        const storyDescription = userStoriesData.description || storyName || 'No description available';
        
        // Escape HTML for data attributes
        const escapedName = storyName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        const escapedDescription = storyDescription.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        
        const formattedHTML = `
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead class="thead-dark">
                <tr>
                  <th>Select</th>
                  <th>Story ID</th>
                  <th>Name</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" name="user_story_ids" 
                      value="${userStoriesData.story_id || 'US1'}" id="story_1"
                      data-name="${escapedName}" 
                      data-description="${escapedDescription}"
                      checked>
                      <label class="form-check-label" for="story_1"></label>
                    </div>
                  </td>
                  <td><strong>${userStoriesData.story_id || 'US1'}</strong></td>
                  <td><strong>${storyName}</strong></td>
                  <td>${storyDescription}</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;
        userStoriesContainer.innerHTML = formattedHTML;
        console.log('Single user story formatted successfully');
        
        // Add event listeners to checkboxes to update hidden form fields
        setupUserStoryCheckboxListeners();
        
        // Trigger change event on the first checkbox to populate hidden fields
        setTimeout(() => {
          const firstCheckbox = document.querySelector('input[name="user_story_ids"]:checked');
          if (firstCheckbox) {
            console.log('Triggering change event on single story checkbox');
            firstCheckbox.dispatchEvent(new Event('change'));
          }
        }, 100);
        
        // Show the user stories section
        const userStoriesSection = document.getElementById('user-stories-section');
        if (userStoriesSection) {
          userStoriesSection.classList.remove('hidden');
        }
        
        return;
      }
    } catch (e) {
      console.log('User stories JSON parse error:', e.message);
      // Leave content as is if parsing fails
    }
  }

  // Initialize card animations
  function initializeCardAnimations() {
    const cards = document.querySelectorAll('.epic-card, .user-story-card');
    cards.forEach((card, index) => {
      card.style.setProperty('--i', index);
      // Add a small delay for staggered animations
      setTimeout(() => {
        card.style.animationPlayState = 'running';
      }, index * 100);
    });
  }

  // Parse epics when page loads
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, checking for epics content...');
    const epicsContainer = document.getElementById('epics-container');
    if (epicsContainer) {
      parseAndFormatEpics();
    }
    
    // Initialize card animations
    initializeCardAnimations();
    
    // Also check for user stories content
    console.log('DOM loaded, checking for user stories content...');
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (userStoriesContainer && userStoriesContainer.innerHTML.trim()) {
      parseAndFormatUserStories();
    }
    
    // Validate button elements are present for debugging
    const approveBtn = document.getElementById('approveEpicsBtn');
    const approveSpinner = document.getElementById('approveSpinner');
    const approveTimer = document.getElementById('approveTimer');
    const proceedBtn = document.getElementById('proceedBtn');
    const proceedSpinner = document.getElementById('proceedSpinner');
    const proceedTimerEl = document.getElementById('proceedTimer');
    
    console.log('Button element validation:');
    console.log('  - Approve button:', !!approveBtn);
    console.log('  - Approve spinner:', !!approveSpinner);
    console.log('  - Approve timer:', !!approveTimer);
    console.log('  - Proceed button:', !!proceedBtn);
    console.log('  - Proceed spinner:', !!proceedSpinner);
    console.log('  - Proceed timer:', !!proceedTimerEl);
    
    // Ensure spinners are initially hidden
    if (approveSpinner) approveSpinner.style.display = 'none';
    if (proceedSpinner) proceedSpinner.style.display = 'none';
  });
  
  // Also try after a slight delay in case content is loaded asynchronously
  setTimeout(function() {
    const epicsContainer = document.getElementById('epics-container');
    if (epicsContainer && epicsContainer.innerHTML.trim()) {
      parseAndFormatEpics();
    }
    
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (userStoriesContainer && userStoriesContainer.innerHTML.trim()) {
      parseAndFormatUserStories();
    }
  }, 500);

  // Epic approval form submission
  document.getElementById("approve-epics-form")?.addEventListener("submit", async function (e) {
    e.preventDefault();
    
    const approveBtn = document.getElementById('approveEpicsBtn');
    const approveSpinner = document.getElementById('approveSpinner');
    const approveTimerEl = document.getElementById('approveTimer');
    
    // Prevent double submission
    if (approveBtn.disabled) {
      console.log('Epic approval already in progress, ignoring duplicate submission');
      return;
    }
    
    // Get current epics content to preserve it
    const epicsContainer = document.getElementById('epics-container');
    const currentEpicsContent = epicsContainer ? epicsContainer.innerHTML : '';
    
    // Collect selected epic IDs and their content from checkboxes
    const selectedEpics = [];
    const selectedEpicContents = {};
    const checkboxes = document.querySelectorAll('input[name="epic_ids"]:checked');
    
    checkboxes.forEach(checkbox => {
      const epicId = checkbox.value;
      selectedEpics.push(epicId);
      
      // Find the epic card containing this checkbox to extract the epic content
      const epicCard = checkbox.closest('.epic-card');
      if (epicCard) {
        // Extract epic title and description
        const titleElement = epicCard.querySelector('h5');
        const descriptionElement = epicCard.querySelector('p');
        
        const epicTitle = titleElement ? titleElement.textContent.replace(/^Epic \d+: /, '') : '';
        const epicDescription = descriptionElement ? descriptionElement.textContent.replace(/^Description: /, '') : '';
        
        selectedEpicContents[epicId] = {
          title: epicTitle,
          description: epicDescription,
          fullContent: epicCard.textContent || ''
        };
      }
    });
    
    if (selectedEpics.length === 0) {
      alert('Please select at least one epic to approve.');
      return;
    }
    
    // Show loading spinner and start timer with better error handling
    let timerInterval = null;
    try {
      timerInterval = showButtonLoading(approveBtn, approveSpinner, approveTimerEl, 'Approve Epic(s)', 'Processing...');
      if (!timerInterval) {
        console.warn('Timer interval not started, fallback loading state');
        approveBtn.disabled = true;
        if (approveSpinner) approveSpinner.style.display = 'block';
        const btnText = approveBtn.querySelector('.btn-text');
        if (btnText) btnText.textContent = 'Processing...';
      }
    } catch (error) {
      console.error('Error starting loading state:', error);
      approveBtn.disabled = true;
    }
    
    // Create form data with selected epics, their content, and current HTML
    const formData = new FormData();
    formData.append('epic_ids', selectedEpics.join(','));
    formData.append('current_epics', currentEpicsContent);
    formData.append('selected_epic_contents', JSON.stringify(selectedEpicContents));
    
    try {
      console.log('Submitting epic approval with selected epics:', selectedEpics);
      
      const response = await fetch("/approve-epics", {
        method: "POST",
        body: formData,
      });
      
      if (response.ok) {
        const html = await response.text();
        // Store timer state before page replacement
        if (timerInterval && approveTimerEl) {
          sessionStorage.setItem('epicApprovalTime', approveTimerEl.textContent || '0:00');
        }
        
        document.open();
        document.write(html);
        document.close();
        
        // After the new page loads, try to parse user stories and restore state
        setTimeout(function() {
          parseAndFormatUserStories();
          
          // Try to restore timer display (though the actual timer won't continue)
          const restoredTime = sessionStorage.getItem('epicApprovalTime');
          if (restoredTime) {
            const timerEl = document.getElementById('approveTimer');
            if (timerEl) {
              timerEl.textContent = restoredTime;
            }
            sessionStorage.removeItem('epicApprovalTime');
          }
        }, 1000);
      } else {
        console.error('Error submitting epic approval:', response.status, response.statusText);
        alert('Error processing epic approval. Please try again.');
      }
    } catch (error) {
      console.error('Error submitting epic approval:', error);
      alert('Network error. Please check your connection and try again.');
    } finally {
      // Hide loading spinner and timer with better error handling
      try {
        hideButtonLoading(approveBtn, approveSpinner, approveTimerEl, 'Approve Epic(s)', timerInterval);
      } catch (error) {
        console.error('Error hiding loading state:', error);
        // Fallback cleanup
        if (approveBtn) {
          approveBtn.disabled = false;
          const btnText = approveBtn.querySelector('.btn-text');
          if (btnText) btnText.textContent = 'Approve Epic(s)';
        }
        if (approveSpinner) approveSpinner.style.display = 'none';
        if (approveTimerEl) approveTimerEl.textContent = '';
        if (timerInterval) clearInterval(timerInterval);
      }
    }
  });

  // User story selection form submission
  document.getElementById("proceed-form")?.addEventListener("submit", async function (e) {
    e.preventDefault();
    
    console.log('üî• FORM SUBMISSION STARTED');
    
    const proceedBtn = document.getElementById('proceedBtn');
    const proceedSpinner = document.getElementById('proceedSpinner');
    const proceedTimerEl = document.getElementById('proceedTimer');
    
    // Prevent double submission
    if (proceedBtn && proceedBtn.disabled) {
      console.log('Proceed submission already in progress, ignoring duplicate submission');
      return;
    }
    
    // Check current form field values
    const storyIdField = document.getElementById("selected_story_id");
    const storyNameField = document.getElementById("selected_story_name");
    const storyDescField = document.getElementById("selected_story_description");
    
    console.log('Current hidden form field values:');
    console.log('  - selected_story_id:', storyIdField ? storyIdField.value : 'FIELD NOT FOUND');
    console.log('  - selected_story_name:', storyNameField ? storyNameField.value : 'FIELD NOT FOUND');
    console.log('  - selected_story_description:', storyDescField ? storyDescField.value : 'FIELD NOT FOUND');
    
    // If form fields are empty, use default values
    if (!storyIdField?.value || !storyNameField?.value) {
      console.log('Form fields are empty, setting default values');
      
      const defaultStoryId = 'default-story-1';
      const defaultStoryName = 'Lock critical fields for charged-off accounts';
      const defaultStoryDescription = 'As a system architect, I want to identify and classify the necessary data fields for charged-off accounts so that we can ensure only required and relevant data is transmitted securely.';
      
      if (storyIdField) storyIdField.value = defaultStoryId;
      if (storyNameField) storyNameField.value = defaultStoryName;
      if (storyDescField) storyDescField.value = defaultStoryDescription;
      
      console.log('Default values set:', {
        id: defaultStoryId,
        name: defaultStoryName,
        description: defaultStoryDescription.substring(0, 50) + '...'
      });
    } else {
      console.log('‚úÖ Form fields already have values, proceeding with current values');
    }
    
    // Show loading spinner and start timer with better error handling
    let timerInterval = null;
    try {
      if (proceedBtn && proceedSpinner && proceedTimerEl) {
        timerInterval = showButtonLoading(proceedBtn, proceedSpinner, proceedTimerEl, 'Proceed To Selection', 'Processing...');
        if (!timerInterval) {
          console.warn('Timer interval not started for proceed button, using fallback');
          proceedBtn.disabled = true;
          proceedSpinner.style.display = 'block';
          const btnText = proceedBtn.querySelector('.btn-text');
          if (btnText) btnText.textContent = 'Processing...';
          proceedTimerEl.textContent = '0:00';
          
          // Manual timer fallback
          let seconds = 0;
          timerInterval = setInterval(() => {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const timeString = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            proceedTimerEl.textContent = timeString;
          }, 1000);
        }
      } else {
        console.warn('Some proceed button elements not found:', {
          button: !!proceedBtn,
          spinner: !!proceedSpinner,
          timer: !!proceedTimerEl
        });
        
        if (proceedBtn) {
          proceedBtn.disabled = true;
          proceedBtn.innerHTML = `
            <span style="display: inline-block; width: 1rem; height: 1rem; border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid white; border-radius: 50%; animation: spin 1s linear infinite;"></span>
            <span style="margin-left: 8px;">Processing...</span>
          `;
        }
      }
    } catch (error) {
      console.error('Error starting proceed loading state:', error);
      if (proceedBtn) proceedBtn.disabled = true;
    }

    try {
      // Get the form and create FormData
      const form = document.getElementById('proceed-form');
      if (!form) {
        console.error('CRITICAL ERROR: Proceed form not found!');
        alert('Form not found. Please refresh the page and try again.');
        return;
      }
      
      // Use FormData to submit the form
      const formData = new FormData(form);

      // Debug: Check form field values right before submission
      console.log('FINAL FORM VALIDATION BEFORE SUBMISSION');
      let hasStoryName = false;
      for (let [key, value] of formData.entries()) {
        const displayValue = value.length > 100 ? value.substring(0, 97) + '...' : value;
        console.log(`  - ${key}: "${displayValue}"`);
        if (key === 'selected_story_name' && value && value.trim() !== '') {
          hasStoryName = true;
          console.log(`‚úÖ STORY NAME FOUND IN FORM DATA: "${value}"`);
        }
      }
      
      if (!hasStoryName) {
        console.error('‚ùå CRITICAL ERROR: NO STORY NAME IN FORM DATA!');
      }

      const response = await fetch("/user-story-details", {
        method: "POST",
        body: formData,
      });

      if (response.ok) {
        const html = await response.text();
        document.open();
        document.write(html);
        document.close();
        console.log('Successfully loaded user story details page.');
      } else {
        console.error('Error submitting user story selection:', response.status, response.statusText);
        const errorText = await response.text();
        console.error('Server error response:', errorText);
        alert(`Error processing user story selection. Status: ${response.status}. Please check the console for details.`);
      }

    } catch (error) {
      console.error('Error submitting user story selection:', error);
      alert('Network error. Please check your connection and try again.');
    } finally {
      // Hide loading spinner and timer with better error handling
      try {
        if (proceedBtn && proceedSpinner && proceedTimerEl && timerInterval) {
          hideButtonLoading(proceedBtn, proceedSpinner, proceedTimerEl, 'Proceed To Selection', timerInterval);
        } else if (proceedBtn) {
          proceedBtn.disabled = false;
          proceedBtn.innerHTML = `
            <span class="btn-spinner" id="proceedSpinner" style="display: none;"></span>
            <span class="btn-text">Proceed To Selection</span>
            <span class="btn-timer" id="proceedTimer"></span>
          `;
          if (timerInterval) clearInterval(timerInterval);
        }
      } catch (error) {
        console.error('Error hiding proceed loading state:', error);
        // Final fallback cleanup
        if (proceedBtn) {
          proceedBtn.disabled = false;
          const btnText = proceedBtn.querySelector('.btn-text');
          if (btnText) btnText.textContent = 'Proceed To Selection';
        }
        if (proceedSpinner) proceedSpinner.style.display = 'none';
        if (proceedTimerEl) proceedTimerEl.textContent = '';
        if (timerInterval) clearInterval(timerInterval);
      }
    }
  });

  // Epic Chat Functionality
  let epicChatHistory = [];

  function openEpicChat() {
    const modal = document.getElementById('epic-chat-modal');
    modal.style.display = 'block';
    
    // Update current epic context
    updateEpicContext();
    
    // Focus on input
    setTimeout(() => {
      document.getElementById('epic-chat-input').focus();
    }, 100);
  }

  function closeEpicChat() {
    const modal = document.getElementById('epic-chat-modal');
    modal.style.display = 'none';
  }

  function clearEpicChat() {
    // Clear the chat messages container (keep only the initial AI message)
    const chatMessages = document.getElementById('epic-chat-messages');
    if (chatMessages) {
      chatMessages.innerHTML = `
        <div class="chat-message assistant">
          <div class="chat-avatar assistant">AI</div>
          <div class="chat-bubble">
            Hello! I'm here to help you with your epics. I can:
            <br>‚Ä¢ Refine existing epic descriptions
            <br>‚Ä¢ Generate new epics based on your requirements
            <br>‚Ä¢ Improve epic titles and details
            <br>‚Ä¢ Suggest epic priorities and breakdowns
            <br><br>What would you like to work on with your epics?
          </div>
        </div>
      `;
    }
    
    // Clear the chat history array
    epicChatHistory = [];
    
    // Clear the input field
    const chatInput = document.getElementById('epic-chat-input');
    if (chatInput) {
      chatInput.value = '';
    }
    
    // Send clear request to backend to clear server-side history
    fetch('/epic-chat-clear', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({})
    })
    .then(response => response.json())
    .then(data => {
      console.log('Epic chat history cleared on server:', data);
    })
    .catch(error => {
      console.error('Error clearing epic chat history on server:', error);
    });
    
    console.log('Epic chat cleared successfully');
  }

  function updateEpicContext() {
    const epicsContainer = document.getElementById('epics-container');
    const contextDisplay = document.getElementById('current-epic-display');
    
    if (epicsContainer) {
      // Try to extract epic information from the displayed content
      const epicCards = epicsContainer.querySelectorAll('.epic-card');
      if (epicCards.length > 0) {
        let contextText = 'Current Epics:\n';
        epicCards.forEach((card, index) => {
          const titleElement = card.querySelector('h5');
          const descElement = card.querySelector('p');
          
          if (titleElement) {
            const title = titleElement.textContent.replace(/^Epic \d+: /, '');
            const desc = descElement ? descElement.textContent.replace(/^Description: /, '') : '';
            contextText += `\n${index + 1}. ${title}\n   ${desc}`;
          }
        });
        contextDisplay.textContent = contextText;
      } else {
        const rawContent = epicsContainer.textContent || epicsContainer.innerHTML;
        if (rawContent && rawContent.trim().length > 0) {
          contextDisplay.textContent = 'Current Epic Content: ' + rawContent.trim().substring(0, 200) + '...';
        } else {
          contextDisplay.textContent = 'No epics content available. I can help you generate new epics.';
        }
      }
    } else {
      contextDisplay.textContent = 'Epic container not found. I can help you generate new epics.';
    }
  }

  function sendEpicMessage() {
    const input = document.getElementById('epic-chat-input');
    const message = input.value.trim();
    
    if (!message) {
      input.focus();
      return;
    }

    const sendBtn = document.getElementById('epic-send-btn');
    const originalHTML = sendBtn.innerHTML;
    
    // Show loading state
    sendBtn.disabled = true;
    sendBtn.innerHTML = `
      <div class="chat-loading">
        <span class="chat-loading-dots"></span>
        Sending...
      </div>
    `;

    // Clear input immediately
    input.value = '';

    // Add user message to display
    addEpicMessage('user', message);
    
    // Show typing indicator
    showEpicTyping();

    // Get current epics context
    const epicsContainer = document.getElementById('epics-container');
    let currentEpicsContext = '';
    
    if (epicsContainer) {
      const epicCards = epicsContainer.querySelectorAll('.epic-card');
      if (epicCards.length > 0) {
        currentEpicsContext = 'Current Epics:\n';
        epicCards.forEach((card, index) => {
          const titleElement = card.querySelector('h5');
          const descElement = card.querySelector('p');
          
          if (titleElement) {
            const title = titleElement.textContent.replace(/^Epic \d+: /, '');
            const desc = descElement ? descElement.textContent.replace(/^Description: /, '') : '';
            currentEpicsContext += `\n${index + 1}. ${title}\n   Description: ${desc}`;
          }
        });
      } else {
        const rawContent = epicsContainer.textContent || epicsContainer.innerHTML;
        if (rawContent && rawContent.trim().length > 0) {
          currentEpicsContext = 'Current Epics Content:\n' + rawContent.trim();
        } else {
          currentEpicsContext = 'No epics content available currently.';
        }
      }
    } else {
      currentEpicsContext = 'Epic container not found.';
    }

    // Send message to backend
    fetch('/epic-chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        message: message,
        current_epics_content: currentEpicsContext
      })
    })
    .then(response => response.json())
    .then(data => {
      hideEpicTyping();
      
      if (data.success) {
        let aiResponse = data.response || data.message || 'No response received';
        
        // Check if the response contains JSON and format it nicely
        let displayResponse = aiResponse;
        let jsonDetected = false;
        
        try {
          // Strategy 1: Try to detect and format JSON in code blocks
          const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/);
          if (jsonMatch) {
            const jsonData = JSON.parse(jsonMatch[1]);
            if (Array.isArray(jsonData)) {
              displayResponse = formatEpicsForDisplay(jsonData);
              jsonDetected = true;
              
              // Show apply button if this looks like updated epics
              setTimeout(() => {
                showApplyEpicsButton(jsonData);
              }, 100);
            }
          }
          
          // Strategy 2: Try to extract bare JSON array pattern
          if (!jsonDetected) {
            const jsonArrayMatch = aiResponse.match(/\[\s*\{[\s\S]*?\}\s*(?:,\s*\{[\s\S]*?\}\s*)*\]/);
            if (jsonArrayMatch) {
              try {
                const jsonData = JSON.parse(jsonArrayMatch[0]);
                if (Array.isArray(jsonData) && jsonData.length > 0) {
                  displayResponse = formatEpicsForDisplay(jsonData);
                  jsonDetected = true;
                  
                  // Show apply button
                  setTimeout(() => {
                    showApplyEpicsButton(jsonData);
                  }, 100);
                }
              } catch (e) {
                console.log('Failed to parse extracted JSON array:', e);
              }
            }
          }
          
          // Strategy 3: Check if the entire response is JSON
          if (!jsonDetected) {
            try {
              const jsonData = JSON.parse(aiResponse.trim());
              if (Array.isArray(jsonData) && jsonData.length > 0) {
                displayResponse = formatEpicsForDisplay(jsonData);
                jsonDetected = true;
                
                // Show apply button
                setTimeout(() => {
                  showApplyEpicsButton(jsonData);
                }, 100);
              }
            } catch (e) {
              // Not pure JSON, keep original response
            }
          }
          
        } catch (e) {
          console.log('JSON parsing error in epic chat:', e);
          // Keep original response if parsing fails
        }
        
        // Add assistant response
        addEpicMessage('assistant', displayResponse);
        epicChatHistory.push({ role: 'user', message: message });
        epicChatHistory.push({ role: 'assistant', message: displayResponse });
        
        setTimeout(() => {
          input.focus();
        }, 100);
      } else {
        console.error('Epic Chat Error:', data.error);
        addEpicMessage('assistant', 'Sorry, I encountered an error. Please try again.');
        removeLastEpicMessage();
      }
    })
    .catch(error => {
      console.error('Epic Chat Network Error:', error);
      hideEpicTyping();
      addEpicMessage('assistant', 'Sorry, I encountered a network error. Please try again.');
      removeLastEpicMessage();
    })
    .finally(() => {
      // Reset button state
      sendBtn.disabled = false;
      sendBtn.innerHTML = originalHTML;
    });
  }

  function addEpicMessage(role, message) {
    const chatMessages = document.getElementById('epic-chat-messages');
    const timestamp = new Date().toLocaleString();
    
    // Process message for better display
    let processedMessage = message;
    processedMessage = processedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    processedMessage = processedMessage.replace(/\*(.*?)\*/g, '<em>$1</em>');
    processedMessage = processedMessage.replace(/\n/g, '<br>');
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${role}`;
    messageDiv.innerHTML = `
      <div class="chat-avatar ${role}">${role === 'user' ? 'U' : 'AI'}</div>
      <div class="chat-bubble">${processedMessage}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function showEpicTyping() {
    const chatMessages = document.getElementById('epic-chat-messages');
    const typingDiv = document.createElement('div');
    typingDiv.className = 'chat-message assistant typing-indicator';
    typingDiv.id = 'epic-typing-indicator';
    typingDiv.innerHTML = `
      <div class="chat-avatar assistant">AI</div>
      <div class="chat-bubble">
        <div class="chat-loading">
          <span class="chat-loading-dots"></span>
          Thinking...
        </div>
      </div>
    `;
    chatMessages.appendChild(typingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function hideEpicTyping() {
    const indicator = document.getElementById('epic-typing-indicator');
    if (indicator) {
      indicator.remove();
    }
  }

  function removeLastEpicMessage() {
    const chatMessages = document.getElementById('epic-chat-messages');
    const userMessages = chatMessages.querySelectorAll('.chat-message.user');
    if (userMessages.length > 0) {
      userMessages[userMessages.length - 1].remove();
    }
  }

  function formatEpicsForDisplay(epicsArray) {
    let formatted = '**Updated Epics:**\n\n';
    epicsArray.forEach((epic, index) => {
      const title = epic.epic_title || epic.title || epic.name || `Epic ${index + 1}`;
      const description = epic.epic_description || epic.description || 'No description available';
      const id = epic.epic_id || epic.id || `epic_${index + 1}`;
      
      formatted += `**${index + 1}. ${title}**\n`;
      formatted += `*ID:* ${id}\n`;
      formatted += `*Description:* ${description}\n\n`;
    });
    return formatted;
  }

  function showApplyEpicsButton(epicsData) {
    const chatMessages = document.getElementById('epic-chat-messages');
    const applyDiv = document.createElement('div');
    applyDiv.className = 'chat-message assistant';
    applyDiv.innerHTML = `
      <div class="chat-avatar assistant">AI</div>
      <div class="chat-bubble">
        <button onclick="applyEpicsUpdate(${JSON.stringify(epicsData).replace(/"/g, '&quot;')})" 
                style="background: #d0021b; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 8px;">
          üìù Apply Epic Updates
        </button>
      </div>
    `;
    chatMessages.appendChild(applyDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function applyEpicsUpdate(epicsData) {
    const epicsContainer = document.getElementById('epics-container');
    if (!epicsContainer) return;

    let formattedHTML = '';
    epicsData.forEach((epic, index) => {
      const epicTitle = epic.epic_title || epic.title || `Untitled Epic ${index + 1}`;
      const epicDescription = epic.epic_description || epic.description || 'No description available.';
      formattedHTML += `
        <div class="epic-card">
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" name="epic_ids" value="epic_${index + 1}" id="epic_${index + 1}">
            <h5 style="margin: 0;">Epic ${index + 1}: ${epicTitle}</h5>
          </div>
          <p><strong>Description:</strong> ${epicDescription}</p>
        </div>
      `;
    });
    
    epicsContainer.innerHTML = formattedHTML;
    updateEpicContext();
    
    // Show success message
    addEpicMessage('assistant', '‚úÖ Epic updates have been applied to the page successfully!');
  }

  // User Story Chat Functionality
  let userStoryChatHistory = [];

  function openUserStoryChat() {
    const modal = document.getElementById('user-story-chat-modal');
    modal.style.display = 'block';
    
    // Update current user story context
    updateUserStoryContext();
    
    // Focus on input
    setTimeout(() => {
      document.getElementById('user-story-chat-input').focus();
    }, 100);
  }

  function closeUserStoryChat() {
    const modal = document.getElementById('user-story-chat-modal');
    modal.style.display = 'none';
  }

  function clearUserStoryChat() {
    // Clear the chat messages container (keep only the initial AI message)
    const chatMessages = document.getElementById('user-story-chat-messages');
    if (chatMessages) {
      chatMessages.innerHTML = `
        <div class="chat-message assistant">
          <div class="chat-avatar assistant">AI</div>
          <div class="chat-bubble">
            Hello! I'm here to help you with your user stories. I can:
            <br>‚Ä¢ Refine existing user story details
            <br>‚Ä¢ Generate additional user stories
            <br>‚Ä¢ Improve user story priorities and descriptions
            <br>‚Ä¢ Suggest better acceptance criteria
            <br><br>What would you like to work on with your user stories?
          </div>
        </div>
      `;
    }
    
    // Clear the chat history array
    userStoryChatHistory = [];
    
    // Clear the input field
    const chatInput = document.getElementById('user-story-chat-input');
    if (chatInput) {
      chatInput.value = '';
    }
    
    // Send clear request to backend to clear server-side history
    fetch('/user-story-chat-clear', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({})
    })
    .then(response => response.json())
    .then(data => {
      console.log('User story chat history cleared on server:', data);
    })
    .catch(error => {
      console.error('Error clearing user story chat history on server:', error);
    });
    
    console.log('User story chat cleared successfully');
  }

  function updateUserStoryContext() {
    const userStoriesContainer = document.getElementById('user-stories-container');
    const contextDisplay = document.getElementById('current-user-story-display');
    
    if (userStoriesContainer) {
      // Try to extract user story information from the displayed content
      const table = userStoriesContainer.querySelector('table');
      if (table) {
        const rows = table.querySelectorAll('tbody tr');
        if (rows.length > 0) {
          let contextText = 'Current User Stories:\n';
          rows.forEach((row, index) => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 3) {
              const storyId = cells[1].textContent.trim();
              const storyName = cells[2].textContent.trim();
              const priority = cells[3] ? cells[3].textContent.trim() : 'N/A';
              contextText += `\n${index + 1}. ${storyId}: ${storyName} (Priority: ${priority})`;
            }
          });
          contextDisplay.textContent = contextText;
        } else {
          contextDisplay.textContent = 'No user stories available. I can help you generate new user stories.';
        }
      } else {
        const rawContent = userStoriesContainer.textContent || userStoriesContainer.innerHTML;
        if (rawContent && rawContent.trim().length > 0) {
          contextDisplay.textContent = 'Current User Story Content: ' + rawContent.trim().substring(0, 200) + '...';
        } else {
          contextDisplay.textContent = 'No user stories content available. I can help you generate new user stories.';
        }
      }
    } else {
      contextDisplay.textContent = 'User stories container not found. I can help you generate new user stories.';
    }
  }

  function sendUserStoryMessage() {
    const input = document.getElementById('user-story-chat-input');
    const message = input.value.trim();
    
    if (!message) {
      input.focus();
      return;
    }

    const sendBtn = document.getElementById('user-story-send-btn');
    const originalHTML = sendBtn.innerHTML;
    
    // Show loading state
    sendBtn.disabled = true;
    sendBtn.innerHTML = `
      <div class="chat-loading">
        <span class="chat-loading-dots"></span>
        Sending...
      </div>
    `;

    // Clear input immediately
    input.value = '';

    // Add user message to display
    addUserStoryMessage('user', message);
    
    // Show typing indicator
    showUserStoryTyping();

    // Get current user story context
    const userStoriesContainer = document.getElementById('user-stories-container');
    let currentUserStoriesContext = '';
    
    if (userStoriesContainer) {
      const table = userStoriesContainer.querySelector('table');
      if (table) {
        const rows = table.querySelectorAll('tbody tr');
        if (rows.length > 0) {
          currentUserStoriesContext = 'Current User Stories:\n';
          rows.forEach((row, index) => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 3) {
              const storyId = cells[1].textContent.trim();
              const storyName = cells[2].textContent.trim();
              const priority = cells[3] ? cells[3].textContent.trim() : 'N/A';
              const systems = cells[4] ? cells[4].textContent.trim() : 'N/A';
              currentUserStoriesContext += `\n${index + 1}. ${storyId}: ${storyName}\n   Priority: ${priority}, Systems: ${systems}`;
            }
          });
        } else {
          currentUserStoriesContext = 'No user stories available currently.';
        }
      } else {
        const rawContent = userStoriesContainer.textContent || userStoriesContainer.innerHTML;
        if (rawContent && rawContent.trim().length > 0) {
          currentUserStoriesContext = 'Current User Stories Content:\n' + rawContent.trim();
        } else {
          currentUserStoriesContext = 'No user stories content available currently.';
        }
      }
    } else {
      currentUserStoriesContext = 'User stories container not found.';
    }

    // Get epic context for user story generation
    const epicsContainer = document.getElementById('epics-container');
    let epicContext = '';
    if (epicsContainer) {
      const epicCards = epicsContainer.querySelectorAll('.epic-card');
      if (epicCards.length > 0) {
        epicContext = '\nRelated Epics:\n';
        epicCards.forEach((card, index) => {
          const titleElement = card.querySelector('h5');
          if (titleElement) {
            const title = titleElement.textContent.replace(/^Epic \d+: /, '');
            epicContext += `${index + 1}. ${title}\n`;
          }
        });
      }
    }

    // Send message to backend
    fetch('/user-story-chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        message: message,
        current_user_stories_content: currentUserStoriesContext,
        epic_context: epicContext
      })
    })
    .then(response => response.json())
    .then(data => {
      hideUserStoryTyping();
      
      if (data.success) {
        let aiResponse = data.response || data.message || 'No response received';
        
        // Check if the response contains JSON and format it nicely
        let displayResponse = aiResponse;
        let jsonDetected = false;
        
        try {
          // Strategy 1: Try to detect and format JSON in code blocks
          const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/);
          if (jsonMatch) {
            const jsonData = JSON.parse(jsonMatch[1]);
            if (Array.isArray(jsonData)) {
              displayResponse = formatUserStoriesForDisplay(jsonData);
              jsonDetected = true;
              
              // Show apply button if this looks like updated user stories
              setTimeout(() => {
                showApplyUserStoriesButton(jsonData);
              }, 100);
            }
          } 
          
          // Strategy 2: Try to extract bare JSON array pattern
          if (!jsonDetected) {
            const jsonArrayMatch = aiResponse.match(/\[\s*\{[\s\S]*?\}\s*(?:,\s*\{[\s\S]*?\}\s*)*\]/);
            if (jsonArrayMatch) {
              try {
                const jsonData = JSON.parse(jsonArrayMatch[0]);
                if (Array.isArray(jsonData) && jsonData.length > 0) {
                  displayResponse = formatUserStoriesForDisplay(jsonData);
                  jsonDetected = true;
                  
                  // Show apply button
                  setTimeout(() => {
                    showApplyUserStoriesButton(jsonData);
                  }, 100);
                }
              } catch (e) {
                console.log('Failed to parse extracted JSON array:', e);
              }
            }
          }
          
          // Strategy 3: Check if the entire response is JSON
          if (!jsonDetected) {
            try {
              const jsonData = JSON.parse(aiResponse.trim());
              if (Array.isArray(jsonData) && jsonData.length > 0) {
                displayResponse = formatUserStoriesForDisplay(jsonData);
                jsonDetected = true;
                
                // Show apply button
                setTimeout(() => {
                  showApplyUserStoriesButton(jsonData);
                }, 100);
              }
            } catch (e) {
              // Not pure JSON, keep original response
            }
          }
          
        } catch (e) {
          console.log('JSON parsing error in user story chat:', e);
          // Keep original response if parsing fails
        }
        
        // Add assistant response
        addUserStoryMessage('assistant', displayResponse);
        userStoryChatHistory.push({ role: 'user', message: message });
        userStoryChatHistory.push({ role: 'assistant', message: displayResponse });
        
        setTimeout(() => {
          input.focus();
        }, 100);
      } else {
        console.error('User Story Chat Error:', data.error);
        addUserStoryMessage('assistant', 'Sorry, I encountered an error. Please try again.');
        removeLastUserStoryMessage();
      }
    })
    .catch(error => {
      console.error('User Story Chat Network Error:', error);
      hideUserStoryTyping();
      addUserStoryMessage('assistant', 'Sorry, I encountered a network error. Please try again.');
      removeLastUserStoryMessage();
    })
    .finally(() => {
      // Reset button state
      sendBtn.disabled = false;
      sendBtn.innerHTML = originalHTML;
    });
  }

  function addUserStoryMessage(role, message) {
    const chatMessages = document.getElementById('user-story-chat-messages');
    const timestamp = new Date().toLocaleString();
    
    // Process message for better display
    let processedMessage = message;
    processedMessage = processedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    processedMessage = processedMessage.replace(/\*(.*?)\*/g, '<em>$1</em>');
    processedMessage = processedMessage.replace(/\n/g, '<br>');
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${role}`;
    messageDiv.innerHTML = `
      <div class="chat-avatar ${role}">${role === 'user' ? 'U' : 'AI'}</div>
      <div class="chat-bubble">${processedMessage}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function showUserStoryTyping() {
    const chatMessages = document.getElementById('user-story-chat-messages');
    const typingDiv = document.createElement('div');
    typingDiv.className = 'chat-message assistant typing-indicator';
    typingDiv.id = 'user-story-typing-indicator';
    typingDiv.innerHTML = `
      <div class="chat-avatar assistant">AI</div>
      <div class="chat-bubble">
        <div class="chat-loading">
          <span class="chat-loading-dots"></span>
          AI is typing...
        </div>
      </div>
    `;
    chatMessages.appendChild(typingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function hideUserStoryTyping() {
    const indicator = document.getElementById('user-story-typing-indicator');
    if (indicator) {
      indicator.remove();
    }
  }

  function removeLastUserStoryMessage() {
    const chatMessages = document.getElementById('user-story-chat-messages');
    const userMessages = chatMessages.querySelectorAll('.chat-message.user');
    if (userMessages.length > 0) {
      userMessages[userMessages.length - 1].remove();
    }
  }

  function formatUserStoriesForDisplay(userStoriesArray) {
    let formatted = '**Updated User Stories:**\n\n';
    userStoriesArray.forEach((story, index) => {
      const storyId = story.story_id || `US-${index + 1}`;
      const storyName = story.name || story.title || `Story ${index + 1}`;
      const priority = story.priority || 'Medium';
      const systems = Array.isArray(story.systems) ? story.systems.join(', ') : (story.systems || 'TBD');
      const description = story.description || 'No description available';
      
      formatted += `**${index + 1}. ${storyName}**\n`;
      formatted += `*ID:* ${storyId}\n`;
      formatted += `*Priority:* ${priority}\n`;
      formatted += `*Systems:* ${systems}\n`;
      formatted += `*Description:* ${description}\n\n`;
    });
    return formatted;
  }

  function showApplyUserStoriesButton(userStoriesData) {
    const chatMessages = document.getElementById('user-story-chat-messages');
    const applyDiv = document.createElement('div');
    applyDiv.className = 'chat-message assistant';
    applyDiv.innerHTML = `
      <div class="chat-avatar assistant">AI</div>
      <div class="chat-bubble">
        <button onclick="applyUserStoriesUpdate(${JSON.stringify(userStoriesData).replace(/"/g, '&quot;')})" 
                style="background: #d0021b; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 8px;">
          üìù Apply User Story Updates
        </button>
      </div>
    `;
    chatMessages.appendChild(applyDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function applyUserStoriesUpdate(userStoriesData) {
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (!userStoriesContainer) return;

    // Store current form values before updating
    const currentFormValues = {
      storyId: document.getElementById('selected_story_id')?.value || '',
      storyName: document.getElementById('selected_story_name')?.value || '',
      storyDescription: document.getElementById('selected_story_description')?.value || '',
      storyPriority: document.getElementById('selected_story_priority')?.value || '',
      storySystems: document.getElementById('selected_story_systems')?.value || '',
      epicTitle: document.getElementById('selected_epic_title')?.value || ''
    };
    
    console.log('Preserving current form values before apply:', currentFormValues);

    // Format the user stories as a table
    let formattedHTML = `
      <div class="table-responsive">
        <table class="table table-striped table-bordered">
          <thead class="thead-dark">
            <tr>
              <th>Select</th>
              <th>Story ID</th>
              <th>Name</th>
              <th>Priority</th>
              <th>Systems</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    // Find which story was previously selected
    let selectedIndex = 0;
    let foundMatch = false;
    
    userStoriesData.forEach((story, index) => {
      const storyId = story.story_id || `US-${index + 1}`;
      const storyName = story.name || story.title || 'Untitled Story';
      
      // Check if this story matches the previously selected one
      if (!foundMatch && currentFormValues.storyId && 
          (storyId === currentFormValues.storyId || 
           storyName === currentFormValues.storyName)) {
        selectedIndex = index;
        foundMatch = true;
        console.log(`Found matching story at index ${index}: ${storyName}`);
      }
    });
    
    userStoriesData.forEach((story, index) => {
      const storyId = story.story_id || `US-${index + 1}`;
      const storyName = story.name || story.title || 'Untitled Story';
      const storyPriority = story.priority || 'Medium';
      const storySystems = Array.isArray(story.systems) ? story.systems.join(', ') : (story.systems || 'TBD');
      const storyDescription = story.description || story.name || 'No description available';
      
      // Escape HTML for data attributes
      const escapedName = storyName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      const escapedDescription = storyDescription.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      
      // Determine priority badge color
      let priorityClass = 'badge-secondary';
      if (storyPriority.toLowerCase() === 'high') {
        priorityClass = 'badge-danger';
      } else if (storyPriority.toLowerCase() === 'medium') {
        priorityClass = 'badge-warning';
      } else if (storyPriority.toLowerCase() === 'low') {
        priorityClass = 'badge-success';
      }
      
      // Select this story if it matches the previously selected one or is the first story
      const isSelected = (foundMatch && index === selectedIndex) || (!foundMatch && index === 0);
      
      formattedHTML += `
        <tr>
          <td>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" name="user_story_ids" 
              value="${storyId}" id="story_${index + 1}"
              data-name="${escapedName}" 
              data-description="${escapedDescription}"
              data-priority="${storyPriority}"
              data-systems="${storySystems}"${isSelected ? ' checked' : ''}>
              <label class="form-check-label" for="story_${index + 1}"></label>
            </div>
          </td>
          <td><strong>${storyId}</strong></td>
          <td><strong>${storyName}</strong></td>
          <td><span class="badge ${priorityClass}">${storyPriority}</span></td>
          <td>${storySystems}</td>
        </tr>
      `;
    });
    
    formattedHTML += `
          </tbody>
        </table>
      </div>
    `;
    
    userStoriesContainer.innerHTML = formattedHTML;
    
    // Re-setup event listeners for new checkboxes
    setupUserStoryCheckboxListeners();
    
    // Show the user stories section
    const userStoriesSection = document.getElementById('user-stories-section');
    if (userStoriesSection) {
      userStoriesSection.classList.remove('hidden');
    }
    
    // Trigger change event on the selected checkbox to populate hidden fields
    setTimeout(() => {
      const selectedCheckbox = document.querySelector('input[name="user_story_ids"]:checked');
      if (selectedCheckbox) {
        console.log('Triggering change event on selected checkbox after apply');
        selectedCheckbox.dispatchEvent(new Event('change'));
        
        // If we had previous form values and this is a different story, restore them
        if (foundMatch && currentFormValues.storyName) {
          setTimeout(() => {
            const storyIdField = document.getElementById('selected_story_id');
            const storyNameField = document.getElementById('selected_story_name');
            const storyDescField = document.getElementById('selected_story_description');
            const storyPriorityField = document.getElementById('selected_story_priority');
            const storySystemsField = document.getElementById('selected_story_systems');
            const epicTitleField = document.getElementById('selected_epic_title');
            
            // Restore epic title if it was previously set
            if (epicTitleField && currentFormValues.epicTitle) {
              epicTitleField.value = currentFormValues.epicTitle;
            }
            
            console.log('Context preserved after user story apply');
          }, 100);
        }
      }
    }, 100);
    
    updateUserStoryContext();
    
    // Show success message
    addUserStoryMessage('assistant', '‚úÖ User story updates have been applied to the page successfully! Your previous selection has been preserved.');
  }

  // Handle Enter key for chat inputs
  document.addEventListener('DOMContentLoaded', function() {
    const epicChatInput = document.getElementById('epic-chat-input');
    const userStoryChatInput = document.getElementById('user-story-chat-input');
    
    if (epicChatInput) {
      epicChatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendEpicMessage();
        }
      });
    }
    
    if (userStoryChatInput) {
      userStoryChatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendUserStoryMessage();
        }
      });
    }
    
    // Close modals when clicking outside
    window.addEventListener('click', function(e) {
      const epicModal = document.getElementById('epic-chat-modal');
      const userStoryModal = document.getElementById('user-story-chat-modal');
      
      if (e.target === epicModal) {
        closeEpicChat();
      }
      if (e.target === userStoryModal) {
        closeUserStoryChat();
      }
    });
  });

</script>

</body>
</html>
