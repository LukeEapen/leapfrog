<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="user-stories-parsing" content="fixed-version" />
  <title>Epic generation & list of user stories</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"/>
  <style>
    body {
      background-color: #2f323a;
      color: #fff;
    }
    .header-bar {
      background-color: #d0021b;
      color: white;
      text-align: center;
      font-weight: bold;
      padding: 10px;
      border-radius: 6px 6px 0 0;
      margin-bottom: 10px;
    }
    .section-header {
      background-color: #444;
      padding: 10px;
      border-radius: 6px;
      font-weight: bold;
      font-size: 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
    }
    .epic-card, .user-story-card {
      background-color: #f8f9fa;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 10px;
      color: #000;
    }
    #epics-container {
      background-color: white;
      border-radius: 6px;
      padding: 15px;
      margin-top: 10px;
      color: #000;
    }
    #user-stories-container {
      background-color: white;
      border-radius: 6px;
      padding: 15px;
      margin-top: 10px;
      color: #000;
    }
    .epic-card h5 {
      color: #d0021b;
      font-weight: bold;
    }
    .priority-high {
      color: red;
      font-weight: bold;
    }
    .priority-medium {
      color: orange;
      font-weight: bold;
    }
    .priority-low {
      color: green;
      font-weight: bold;
    }
    .footer-btn {
      background-color: #d0021b;
      color: white;
      font-weight: bold;
      padding: 10px;
      width: 100%;
      border-radius: 10px;
      border: none;
      margin-top: 20px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .footer-btn:disabled {
      background-color: #666;
      cursor: not-allowed;
    }

    .footer-btn .btn-spinner {
      width: 1rem;
      height: 1rem;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    .footer-btn .btn-timer {
      font-size: 0.9rem;
      font-weight: normal;
      color: rgba(255, 255, 255, 0.8);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .hidden {
      display: none;
    }
    
    /* User stories table styling */
    .table {
      background-color: white;
      border-radius: 6px;
      overflow: hidden;
    }
    .table th {
      background-color: #343a40;
      color: white;
      border: none;
      font-weight: bold;
      vertical-align: middle;
    }
    .table td {
      vertical-align: middle;
      border-color: #dee2e6;
    }
    .table-striped tbody tr:nth-of-type(odd) {
      background-color: #f8f9fa;
    }
    .badge {
      font-size: 0.8em;
    }
    .form-check-input:checked {
      background-color: #d0021b;
      border-color: #d0021b;
    }
  </style>
</head>
<body>
<div class="container mt-4">
  <div class="header-bar">Epic generation & list of user stories</div>
  
  <!-- Project Info Section -->
  <div style="background-color: #444; color: white; padding: 8px 15px; border-radius: 4px; margin: 10px 0; font-size: 0.9rem;">
    <span>🎫 JIRA Project: <strong>{{ jira_project_key or 'SCRUM' }}</strong></span>
  </div>
  
  <div class="section-header">
    <span>Epics</span>
    <button class="btn btn-outline-light btn-sm" id="epicChatBtn" onclick="openEpicChat()">💬 Chat</button>
  </div>
  
  <div id="epics-container">
    {{ epics|safe }}
  </div>
  
  <form id="approve-epics-form" method="POST" action="/approve-epics">
    <input type="hidden" name="epic_ids" id="epic_ids" value="epic_1,epic_2">
    <button type="submit" class="footer-btn" id="approveEpicsBtn">
      <span class="btn-spinner" id="approveSpinner"></span>
      <span class="btn-text">Approve Epic(s)</span>
      <span class="btn-timer" id="approveTimer"></span>
    </button>
  </form>

  <div id="user-stories-section" class="{{ 'hidden' if not user_stories }}">
    <div class="section-header">
      <span>User stories</span>
      <button class="btn btn-outline-light btn-sm" id="userStoryChatBtn" onclick="openUserStoryChat()">💬 User Story Chat</button>
    </div>
    <p class="mb-3 text-light">
      Review this list of generated user stories for each epic, sorted by the solution's ranking of priority based on industry and uploaded context. Select <strong>one</strong> story to proceed with generating a detailed user story.
    </p>
    <form id="proceed-form" method="POST" action="/user-story-details">
      <div id="user-stories-container">
        {{ user_stories|safe }}
      </div>    
      <input type="hidden" name="selected_story_id" id="selected_story_id">
      <input type="hidden" name="selected_story_name" id="selected_story_name">
      <input type="hidden" name="selected_story_description" id="selected_story_description">
      <input type="hidden" name="selected_story_priority" id="selected_story_priority">
      <input type="hidden" name="selected_story_systems" id="selected_story_systems">
      <input type="hidden" name="epic_title" id="selected_epic_title">
      <button type="submit" class="footer-btn" id="proceedBtn">
        <span class="btn-spinner" id="proceedSpinner"></span>
        <span class="btn-text">Proceed To Selection</span>
        <span class="btn-timer" id="proceedTimer"></span>
      </button>
    </form>
  </div>
</div>

<script>  
  // Timer and spinner utility functions
  let approveTimer = null;
  let proceedTimer = null;
  let userStoriesParsed = false; // Flag to prevent multiple parsing attempts
  let isParsingUserStories = false; // Lock to prevent concurrent parsing
  let lastParsedContentHash = ''; // Hash of last successfully parsed content

  // Make flags globally accessible and more persistent
  window.userStoriesParsed = false;
  window.isParsingUserStories = false;
  window.lastParsedContentHash = '';

  function startTimer(timerId, buttonTimerElement) {
    if (!buttonTimerElement) {
      console.error('startTimer: buttonTimerElement is null');
      return null;
    }
    
    let seconds = 0;
    return setInterval(() => {
      seconds++;
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      const timeString = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
      buttonTimerElement.textContent = timeString;
    }, 1000);
  }

  function showButtonLoading(button, spinner, timer, buttonText, loadingText) {
    if (!button || !spinner || !timer) {
      console.error('showButtonLoading: missing elements');
      return null;
    }

    try {
      button.disabled = true;
      spinner.style.display = 'block';
      
      const btnTextElement = button.querySelector('.btn-text');
      if (btnTextElement) {
        btnTextElement.textContent = loadingText;
      }
      
      timer.textContent = '0:00';
      const intervalId = startTimer(null, timer);
      
      return intervalId;
    } catch (error) {
      console.error('Error in showButtonLoading:', error);
      return null;
    }
  }

  function hideButtonLoading(button, spinner, timer, originalText, timerInterval) {
    if (!button || !spinner || !timer) {
      console.warn('hideButtonLoading: some elements are null');
      return;
    }

    try {
      button.disabled = false;
      spinner.style.display = 'none';
      
      const btnTextElement = button.querySelector('.btn-text');
      if (btnTextElement) {
        btnTextElement.textContent = originalText;
      }
      
      timer.textContent = '';
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    } catch (error) {
      console.error('Error in hideButtonLoading:', error);
    }
  }

  // Function to parse and format epics if they're in JSON format
  function parseAndFormatEpics() {
    const epicsContainer = document.getElementById('epics-container');
    let content = epicsContainer.innerHTML.trim();
    
    // If content is already formatted (contains epic-card divs), don't reprocess
    if (content.includes('epic-card')) {
      return;
    }
    
    // Remove any HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    content = tempDiv.textContent || tempDiv.innerText || '';
    content = content.trim();
    
    // If content is empty or very short, leave it as is
    if (!content || content.length < 5) {
      return;
    }
    
    try {
      // Clean up the content - remove any backticks or markdown formatting
      let cleanContent = content;
      if (cleanContent.startsWith('```json')) {
        cleanContent = cleanContent.replace(/^```json\s*/i, '').replace(/\s*```\s*$/, '');
      }
      if (cleanContent.startsWith('```')) {
        cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```\s*$/, '');
      }
      
      // Try to parse as JSON
      const epicsData = JSON.parse(cleanContent);
      
      if (Array.isArray(epicsData)) {
        // Format the epics nicely
        let formattedHTML = '';
        epicsData.forEach((epic, index) => {
          formattedHTML += `
            <div class="epic-card">
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" name="epic_ids" value="epic_${index + 1}" id="epic_${index + 1}">
                <h5 style="margin: 0;">Epic ${index + 1}: ${epic.epic_title || 'Untitled Epic'}</h5>
              </div>
              <p><strong>Description:</strong> ${epic.epic_description || 'No description available'}</p>
            </div>
          `;
        });
        
        epicsContainer.innerHTML = formattedHTML;
        return;
      } else if (epicsData && typeof epicsData === 'object') {
        // Handle single epic object
        const formattedHTML = `
          <div class="epic-card">
            <div style="display: flex; align-items: center; gap: 10px;">
              <input type="checkbox" name="epic_ids" value="epic_1" id="epic_1">
              <h5 style="margin: 0;">Epic 1: ${epicsData.epic_title || 'Untitled Epic'}</h5>
            </div>
            <p><strong>Description:</strong> ${epicsData.epic_description || 'No description available'}</p>
          </div>
        `;
        epicsContainer.innerHTML = formattedHTML;
        return;
      }
    } catch (e) {
      // Try to extract JSON from text that might have extra content
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        try {
          const epicsData = JSON.parse(jsonMatch[0]);
          if (Array.isArray(epicsData)) {
            let formattedHTML = '';
            epicsData.forEach((epic, index) => {
              formattedHTML += `
                <div class="epic-card">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" name="epic_ids" value="epic_${index + 1}" id="epic_${index + 1}">
                    <h5 style="margin: 0;">Epic ${index + 1}: ${epic.epic_title || 'Untitled Epic'}</h5>
                  </div>
                  <p><strong>Description:</strong> ${epic.epic_description || 'No description available'}</p>
                </div>
              `;
            });
            epicsContainer.innerHTML = formattedHTML;
            return;
          }
        } catch (e2) {
          // If all parsing fails, leave content as is
        }
      }
    }
  }

  // Function to set up event listeners for user story checkboxes
  function setupUserStoryCheckboxListeners() {
    console.log('Setting up user story checkbox event listeners');
    
    // Get all user story checkboxes
    const checkboxes = document.querySelectorAll('input[name="user_story_ids"]');
    console.log(`Found ${checkboxes.length} user story checkboxes`);
    
    checkboxes.forEach((checkbox, index) => {
      checkbox.addEventListener('change', function() {
        console.log(`Checkbox ${index} changed, checked: ${this.checked}`);
        
        if (this.checked) {
          // Uncheck other checkboxes (single selection)
          checkboxes.forEach(cb => {
            if (cb !== this) cb.checked = false;
          });
          
          // Update hidden form fields
          const storyId = this.value;
          const storyName = this.getAttribute('data-name');
          const storyDescription = this.getAttribute('data-description');
          const storyPriority = this.getAttribute('data-priority');
          const storySystems = this.getAttribute('data-systems');
          
          console.log('Updating hidden form fields with:', {
            id: storyId,
            name: storyName,
            description: storyDescription ? storyDescription.substring(0, 50) + '...' : 'N/A',
            priority: storyPriority,
            systems: storySystems
          });
          
          // Set hidden form field values
          const storyIdField = document.getElementById('selected_story_id');
          const storyNameField = document.getElementById('selected_story_name');
          const storyDescField = document.getElementById('selected_story_description');
          const storyPriorityField = document.getElementById('selected_story_priority');
          const storySystemsField = document.getElementById('selected_story_systems');
          
          if (storyIdField) storyIdField.value = storyId || '';
          if (storyNameField) storyNameField.value = storyName || '';
          if (storyDescField) storyDescField.value = storyDescription || '';
          if (storyPriorityField) storyPriorityField.value = storyPriority || 'Medium';
          if (storySystemsField) storySystemsField.value = storySystems || '';
          
          // Also populate epic title from page context
          const epicTitleField = document.getElementById('selected_epic_title');
          if (epicTitleField) {
            // Try to get epic title from the currently selected/visible epic
            const selectedEpicCheckbox = document.querySelector('input[name="epic_ids"]:checked');
            let epicTitle = '';
            
            if (selectedEpicCheckbox) {
              const epicCard = selectedEpicCheckbox.closest('.epic-card');
              if (epicCard) {
                const titleElement = epicCard.querySelector('h5');
                if (titleElement) {
                  epicTitle = titleElement.textContent.replace(/^Epic \d+: /, '').trim();
                }
              }
            }
            
            // Fallback: try to get from first epic if none selected
            if (!epicTitle) {
              const firstEpicCard = document.querySelector('.epic-card');
              if (firstEpicCard) {
                const titleElement = firstEpicCard.querySelector('h5');
                if (titleElement) {
                  epicTitle = titleElement.textContent.replace(/^Epic \d+: /, '').trim();
                }
              }
            }
            
            epicTitleField.value = epicTitle || 'User Story Epic';
          }
          
          console.log('Hidden form fields updated successfully');
        }
      });
    });
    
    console.log('User story checkbox event listeners set up successfully');
  }

  // Function to parse and format user stories if they're in JSON format
  function parseAndFormatUserStories() {
    // SAFETY CHECK: Ensure this is the fixed version of the template
    const metaTag = document.querySelector('meta[name="user-stories-parsing"]');
    if (!metaTag || metaTag.getAttribute('content') !== 'fixed-version') {
      console.warn('Not the fixed version template, skipping user stories parsing');
      return;
    }
    
    // Prevent concurrent parsing
    if (window.isParsingUserStories || isParsingUserStories) {
      console.log('User stories parsing already in progress, skipping');
      return;
    }
    
    // Check if already parsed
    if (window.userStoriesParsed || userStoriesParsed) {
      console.log('User stories already parsed, skipping');
      return;
    }
    
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (!userStoriesContainer) {
      console.log('User stories container not found');
      return;
    }
    
    // Set the parsing locks
    window.isParsingUserStories = true;
    isParsingUserStories = true;
    console.log('Starting user stories parsing...');
    
    let content = userStoriesContainer.innerHTML.trim();
    console.log('Raw user stories content length:', content.length);
    console.log('First 200 chars:', content.substring(0, 200));
    
    // Generate a simple hash of the content
    const contentHash = content.split('').reduce((a, b) => {
      a = ((a << 5) - a) + b.charCodeAt(0);
      return a & a;
    }, 0).toString();
    
    // Check if we've already parsed this exact content
    if (contentHash === window.lastParsedContentHash || contentHash === lastParsedContentHash) {
      console.log('🔒 Content hash matches previously parsed content, skipping re-parse');
      window.userStoriesParsed = true;
      userStoriesParsed = true;
      window.isParsingUserStories = false;
      isParsingUserStories = false;
      setupUserStoryCheckboxListeners(); // Ensure listeners are set up
      return;
    }
    
    // CRITICAL FIX: ULTRA-ROBUST check for already formatted content
    // This check will catch any form of formatted table and prevent re-parsing forever
    if (content.includes('user-story-card') || 
        content.includes('<table') || 
        content.includes('table-responsive') ||
        content.includes('form-check-input') ||
        content.includes('name="user_story_ids"') ||
        content.includes('class="table table-striped') ||
        content.includes('thead-dark') ||
        content.includes('story_id') ||
        content.includes('badge-') ||
        content.includes('Select</th>') ||
        content.includes('Story ID</th>') ||
        content.includes('Priority</th>') ||
        content.includes('Systems</th>') ||
        (content.includes('<tr>') && content.includes('<td>')) ||
        (content.includes('checkbox') && content.includes('data-name')) ||
        content.includes('table-striped') ||
        content.includes('table-bordered') ||
        content.includes('form-check')) {
      console.log('🚫 User stories already formatted as table - PERMANENT BLOCK on re-parsing');
      window.userStoriesParsed = true; // Mark as parsed permanently
      userStoriesParsed = true;
      window.isParsingUserStories = false; // Release locks
      isParsingUserStories = false;
      setupUserStoryCheckboxListeners(); // Ensure listeners are set up
      return;
    }
    
    // Remove any HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    content = tempDiv.textContent || tempDiv.innerText || '';
    content = content.trim();
    
    // If content is empty or very short, leave it as is
    if (!content || content.length < 10) {
      console.log('User stories content too short or empty, skipping parsing');
      window.isParsingUserStories = false; // Release locks
      isParsingUserStories = false;
      return;
    }
    
    // STRICTER JSON CHECK: Must start with [ and contain user story indicators
    const looksLikeJSON = content.startsWith('[') && 
                         (content.includes('"story_id"') || content.includes('"name"') || 
                          content.includes('"title"') || content.includes('"priority"'));
    
    if (!looksLikeJSON) {
      console.log('Content does not appear to be valid user stories JSON, skipping parsing');
      window.isParsingUserStories = false; // Release locks
      isParsingUserStories = false;
      return;
    }

    try {
      // Multiple strategies to extract JSON from text
      let cleanContent = content;
      let extractionMethod = 'direct';
      
      // Strategy 1: Look for markdown-wrapped JSON
      if (cleanContent.includes('```json')) {
        const jsonMatch = cleanContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          cleanContent = jsonMatch[1].trim();
          extractionMethod = 'markdown-json';
        }
      } 
      // Strategy 2: Look for any code block with ```
      else if (cleanContent.includes('```')) {
        const codeBlockMatch = cleanContent.match(/```\s*([\s\S]*?)\s*```/);
        if (codeBlockMatch && codeBlockMatch[1]) {
          cleanContent = codeBlockMatch[1].trim();
          extractionMethod = 'markdown-code';
        }
      }
      
      // Strategy 3: Look for JSON array pattern (most robust)
      const jsonArrayPattern = /\[\s*\{[\s\S]*?\}\s*(?:,\s*\{[\s\S]*?\}\s*)*\]/;
      const jsonArrayMatch = cleanContent.match(jsonArrayPattern);
      if (jsonArrayMatch) {
        cleanContent = jsonArrayMatch[0];
        extractionMethod = 'regex-array';
      }
      
      console.log(`User stories extraction method: ${extractionMethod}`);
      
      // Try to parse as JSON
      const userStoriesData = JSON.parse(cleanContent);
      
      if (Array.isArray(userStoriesData) && userStoriesData.length > 0) {
        console.log('Successfully parsed user stories array:', userStoriesData);
        
        // Format the user stories as a table
        let formattedHTML = `
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead class="thead-dark">
                <tr>
                  <th>Select</th>
                  <th>Story ID</th>
                  <th>Name</th>
                  <th>Priority</th>
                  <th>Systems</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        userStoriesData.forEach((story, index) => {
          // Handle the new agent response format
          const storyId = story.story_id || `US-${index + 1}`;
          const storyName = story.name || story.title || 'Untitled Story';
          const storyPriority = story.priority || 'Medium';
          const storySystems = Array.isArray(story.systems) ? story.systems.join(', ') : (story.systems || 'TBD');
          
          // Use the story name as description if no separate description field
          const storyDescription = story.description || story.name || 'No description available';
          
          // Escape HTML for data attributes to prevent attribute breaking
          const escapedName = storyName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
          const escapedDescription = storyDescription.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
          
          // Determine priority badge color
          let priorityClass = 'badge-secondary';
          if (storyPriority.toLowerCase() === 'high') {
            priorityClass = 'badge-danger';
          } else if (storyPriority.toLowerCase() === 'medium') {
            priorityClass = 'badge-warning';
          } else if (storyPriority.toLowerCase() === 'low') {
            priorityClass = 'badge-success';
          }
          
          formattedHTML += `
            <tr>
              <td>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" name="user_story_ids" 
                  value="${storyId}" id="story_${index + 1}"
                  data-name="${escapedName}" 
                  data-description="${escapedDescription}"
                  data-priority="${storyPriority}"
                  data-systems="${storySystems}"${index === 0 ? ' checked' : ''}>
                  <label class="form-check-label" for="story_${index + 1}"></label>
                </div>
              </td>
              <td><strong>${storyId}</strong></td>
              <td><strong>${storyName}</strong></td>
              <td><span class="badge ${priorityClass}">${storyPriority}</span></td>
              <td>${storySystems}</td>
            </tr>
          `;
        });
        
        formattedHTML += `
              </tbody>
            </table>
          </div>
        `;
        
        userStoriesContainer.innerHTML = formattedHTML;
        console.log('✅ User stories formatted successfully as table - PERMANENT LOCK ENGAGED');
        
        // Store content hash to prevent re-parsing
        window.lastParsedContentHash = contentHash;
        lastParsedContentHash = contentHash;
        
        // Set permanent parsing flags IMMEDIATELY to prevent any further mutation observer triggers
        window.userStoriesParsed = true; // Mark as successfully parsed PERMANENTLY
        userStoriesParsed = true;
        window.isParsingUserStories = false; // Release locks
        isParsingUserStories = false;
        
        // CRITICAL: Disconnect mutation observer immediately after successful parse
        if (window.userStoriesMutationObserver) {
          window.userStoriesMutationObserver.disconnect();
          console.log('🚫 MUTATION OBSERVER FORCIBLY DISCONNECTED AFTER SUCCESSFUL PARSE');
          window.userStoriesMutationObserver = null;
        }
        
        // Add event listeners to checkboxes to update hidden form fields
        setupUserStoryCheckboxListeners();
        
        // Trigger change event on the first checkbox to populate hidden fields
        setTimeout(() => {
          const firstCheckbox = document.querySelector('input[name="user_story_ids"]:checked');
          if (firstCheckbox) {
            console.log('Triggering change event on first checkbox');
            firstCheckbox.dispatchEvent(new Event('change'));
          }
        }, 100);
        
        // Show the user stories section
        const userStoriesSection = document.getElementById('user-stories-section');
        if (userStoriesSection) {
          userStoriesSection.classList.remove('hidden');
        }
        
        // FINAL SAFETY: Forcibly disconnect observer after successful formatting
        setTimeout(() => {
          window.forceDisconnectUserStoriesObserver();
        }, 2000);
        
        return;
      } else if (userStoriesData && typeof userStoriesData === 'object') {
        // Handle single user story object
        console.log('Single user story object detected');
        
        const storyName = userStoriesData.name || userStoriesData.title || 'Untitled Story';
        const storyDescription = userStoriesData.description || storyName || 'No description available';
        
        // Escape HTML for data attributes
        const escapedName = storyName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        const escapedDescription = storyDescription.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        
        const formattedHTML = `
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead class="thead-dark">
                <tr>
                  <th>Select</th>
                  <th>Story ID</th>
                  <th>Name</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" name="user_story_ids" 
                      value="${userStoriesData.story_id || 'story_1'}" id="story_1"
                      data-name="${escapedName}" 
                      data-description="${escapedDescription}"
                      data-epic-id="${userStoriesData.epic_id || ''}"
                      data-priority="${userStoriesData.priority || 'medium'}" checked>
                      <label class="form-check-label" for="story_1"></label>
                    </div>
                  </td>
                  <td><strong>${userStoriesData.story_id || 'US1'}</strong></td>
                  <td><strong>${storyName}</strong></td>
                  <td>${storyDescription}</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;
        userStoriesContainer.innerHTML = formattedHTML;
        console.log('✅ Single user story formatted successfully - PERMANENT LOCK ENGAGED');
        
        // Store content hash to prevent re-parsing
        window.lastParsedContentHash = contentHash;
        lastParsedContentHash = contentHash;
        
        // Set permanent parsing flags IMMEDIATELY to prevent any further mutation observer triggers
        window.userStoriesParsed = true; // Mark as successfully parsed PERMANENTLY
        userStoriesParsed = true;
        window.isParsingUserStories = false; // Release locks
        isParsingUserStories = false;
        
        // CRITICAL: Disconnect mutation observer immediately after successful parse
        if (window.userStoriesMutationObserver) {
          window.userStoriesMutationObserver.disconnect();
          console.log('🚫 MUTATION OBSERVER FORCIBLY DISCONNECTED AFTER SUCCESSFUL PARSE');
          window.userStoriesMutationObserver = null;
        }
        
        // Add event listeners to checkboxes to update hidden form fields
        setupUserStoryCheckboxListeners();
        
        // Trigger change event on the first checkbox to populate hidden fields
        setTimeout(() => {
          const firstCheckbox = document.querySelector('input[name="user_story_ids"]:checked');
          if (firstCheckbox) {
            console.log('Triggering change event on single story checkbox');
            firstCheckbox.dispatchEvent(new Event('change'));
          }
        }, 100);
        
        // Show the user stories section
        const userStoriesSection = document.getElementById('user-stories-section');
        if (userStoriesSection) {
          userStoriesSection.classList.remove('hidden');
        }
        
        // FINAL SAFETY: Forcibly disconnect observer after successful formatting
        setTimeout(() => {
          window.forceDisconnectUserStoriesObserver();
        }, 2000);
        
        return;
      }
    } catch (e) {
      console.log('User stories JSON parse error:', e.message);
      // Leave content as is if parsing fails
      window.isParsingUserStories = false; // Release locks on error
      isParsingUserStories = false;
    }
    
    // Ensure locks are always released
    window.isParsingUserStories = false;
    isParsingUserStories = false;
  }

  // Parse epics and user stories when page loads - ONLY ONCE
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing page...');
    
    // Parse epics
    const epicsContainer = document.getElementById('epics-container');
    if (epicsContainer) {
      parseAndFormatEpics();
    }
    
    // Parse user stories only once on DOM load
    const userStoriesContainer = document.getElementById('user-stories-container');
    if (userStoriesContainer && userStoriesContainer.innerHTML.trim()) {
      const content = userStoriesContainer.innerHTML.trim();
      
      // Check if user stories are already formatted as a table
      if (content.includes('table-responsive') || content.includes('form-check-input') || 
          content.includes('name="user_story_ids"') || content.includes('story_id')) {
        console.log('🔒 User stories already formatted on page load - PERMANENT LOCK ENGAGED');
        window.userStoriesParsed = true;
        userStoriesParsed = true;
        setupUserStoryCheckboxListeners(); // Ensure listeners are set up
        
        // Forcibly disconnect any mutation observer that might exist
        if (window.userStoriesMutationObserver) {
          window.userStoriesMutationObserver.disconnect();
          console.log('🚫 MUTATION OBSERVER DISCONNECTED - STORIES ALREADY FORMATTED');
          window.userStoriesMutationObserver = null;
        }
      } else if (!window.userStoriesParsed && !userStoriesParsed) {
        console.log('Attempting to parse user stories on DOM load');
        parseAndFormatUserStories();
      }
    }
    
    // Set up a ONE-TIME ONLY mutation observer with ULTRA-STRICT conditions to prevent re-parsing
    if (userStoriesContainer && !window.userStoriesMutationObserver) {
      let observerTriggered = false; // Additional safety flag
      
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          // ULTIMATE SAFETY CHECK: Multiple layers of protection
          if (mutation.type === 'childList' && 
              !observerTriggered &&
              !window.userStoriesParsed && !userStoriesParsed && 
              !window.isParsingUserStories && !isParsingUserStories) {
            
            observerTriggered = true; // Mark observer as triggered
            console.log('User stories content changed, checking if parsing needed...');
            const content = userStoriesContainer.innerHTML.trim();
            
            // ULTRA-STRICT CONDITIONS: Only parse if content is definitely raw JSON user stories
            // and contains ZERO formatted table elements
            const looksLikeRawJSON = content.startsWith('[') && 
                                   !content.includes('<table') &&
                                   !content.includes('form-check-input') &&
                                   !content.includes('name="user_story_ids"') &&
                                   !content.includes('<tr>') &&
                                   !content.includes('<td>') &&
                                   !content.includes('<th>') &&
                                   !content.includes('table-responsive') &&
                                   !content.includes('table-striped') &&
                                   !content.includes('thead-dark') &&
                                   !content.includes('badge-') &&
                                   !content.includes('form-check') &&
                                   !content.includes('checkbox') &&
                                   (content.includes('"story_id"') || content.includes('"name"') || content.includes('"title"'));
            
            if (looksLikeRawJSON && content.length > 50) {
              console.log('🔥 FINAL PARSING ATTEMPT - Raw JSON user stories detected...');
              parseAndFormatUserStories();
              
              // DISCONNECT OBSERVER PERMANENTLY after first parsing attempt
              setTimeout(() => {
                if (window.userStoriesMutationObserver) {
                  window.userStoriesMutationObserver.disconnect();
                  console.log('🚫 MUTATION OBSERVER PERMANENTLY DISCONNECTED AFTER PARSING');
                  window.userStoriesMutationObserver = null;
                }
              }, 1000);
            } else {
              console.log('Content change ignored - either not raw JSON or already formatted');
              // Reset flag if we didn't parse
              observerTriggered = false;
            }
          } else {
            console.log('Content change BLOCKED - safety conditions not met');
            if (window.userStoriesParsed || userStoriesParsed) {
              console.log('🔒 PERMANENTLY BLOCKED - user stories already parsed and formatted');
              // Disconnect observer if parsing is complete
              if (window.userStoriesMutationObserver) {
                window.userStoriesMutationObserver.disconnect();
                console.log('🚫 MUTATION OBSERVER DISCONNECTED - PARSING COMPLETE');
                window.userStoriesMutationObserver = null;
              }
            }
          }
        });
      });
      
      // Store observer reference globally for forced disconnection
      window.userStoriesMutationObserver = observer;
      
      // Only observe child list changes, not subtree (less aggressive)
      observer.observe(userStoriesContainer, { childList: true, subtree: false });
      
      // Auto-disconnect observer after 30 seconds as final safety measure
      setTimeout(() => {
        try {
          if (window.userStoriesMutationObserver) {
            window.userStoriesMutationObserver.disconnect();
            console.log('⏰ MUTATION OBSERVER AUTO-DISCONNECTED (30s timeout)');
            window.userStoriesMutationObserver = null;
          }
        } catch (e) {
          console.log('Observer already disconnected');
        }
      }, 30000);
    } else if (window.userStoriesMutationObserver) {
      console.log('🚫 MUTATION OBSERVER ALREADY EXISTS - SKIPPING SETUP');
    }
  });

  // Epic approval form submission
  document.getElementById("approve-epics-form")?.addEventListener("submit", async function (e) {
    e.preventDefault();
    
    const approveBtn = document.getElementById('approveEpicsBtn');
    const approveSpinner = document.getElementById('approveSpinner');
    const approveTimerEl = document.getElementById('approveTimer');
    
    // Get current epics content to preserve it
    const epicsContainer = document.getElementById('epics-container');
    const currentEpicsContent = epicsContainer ? epicsContainer.innerHTML : '';
    
    // Collect selected epic IDs and their content from checkboxes
    const selectedEpics = [];
    const selectedEpicContents = {};
    const checkboxes = document.querySelectorAll('input[name="epic_ids"]:checked');
    
    checkboxes.forEach(checkbox => {
      const epicId = checkbox.value;
      selectedEpics.push(epicId);
      
      // Find the epic card containing this checkbox to extract the epic content
      const epicCard = checkbox.closest('.epic-card');
      if (epicCard) {
        // Extract epic title and description
        const titleElement = epicCard.querySelector('h5');
        const descriptionElement = epicCard.querySelector('p');
        
        const epicTitle = titleElement ? titleElement.textContent.replace(/^Epic \d+: /, '') : '';
        const epicDescription = descriptionElement ? descriptionElement.textContent.replace(/^Description: /, '') : '';
        
        selectedEpicContents[epicId] = {
          title: epicTitle,
          description: epicDescription,
          fullContent: epicCard.textContent || ''
        };
      }
    });
    
    if (selectedEpics.length === 0) {
      alert('Please select at least one epic to approve.');
      return;
    }
    
    // Show loading spinner and start timer
    approveTimer = showButtonLoading(approveBtn, approveSpinner, approveTimerEl, 'Approve Epic(s)', 'Processing...');
    
    // Create form data with selected epics, their content, and current HTML
    const formData = new FormData();
    formData.append('epic_ids', selectedEpics.join(','));
    formData.append('current_epics', currentEpicsContent);
    formData.append('selected_epic_contents', JSON.stringify(selectedEpicContents));
    
    try {
      console.log('Submitting epic approval with selected epics:', selectedEpics);
      
      const response = await fetch("/approve-epics", {
        method: "POST",
        body: formData,
      });
      
      if (response.ok) {
        const html = await response.text();
        document.open();
        document.write(html);
        document.close();
        
        // Don't reset the parsed flag immediately - let the new page handle it
        console.log('Epic approval successful, new page loaded');
      } else {
        console.error('Error submitting epic approval:', response.statusText);
        alert('Error processing epic approval. Please try again.');
      }
    } catch (error) {
      console.error('Error submitting epic approval:', error);
      alert('Network error. Please check your connection and try again.');
    } finally {
      // Hide loading spinner and timer
      hideButtonLoading(approveBtn, approveSpinner, approveTimerEl, 'Approve Epic(s)', approveTimer);
    }
  });

  // User story selection form submission
  document.getElementById("proceed-form")?.addEventListener("submit", async function (e) {
    e.preventDefault();
    
    console.log('🔥 FORM SUBMISSION STARTED');
    
    const proceedBtn = document.getElementById('proceedBtn');
    const proceedSpinner = document.getElementById('proceedSpinner');
    const proceedTimerEl = document.getElementById('proceedTimer');
    
    // Check current form field values
    const storyIdField = document.getElementById("selected_story_id");
    const storyNameField = document.getElementById("selected_story_name");
    const storyDescField = document.getElementById("selected_story_description");
    
    console.log('Current hidden form field values:');
    console.log('  - selected_story_id:', storyIdField ? storyIdField.value : 'FIELD NOT FOUND');
    console.log('  - selected_story_name:', storyNameField ? storyNameField.value : 'FIELD NOT FOUND');
    console.log('  - selected_story_description:', storyDescField ? storyDescField.value : 'FIELD NOT FOUND');
    
    // If form fields are empty, use default values
    if (!storyIdField?.value || !storyNameField?.value) {
      console.log('Form fields are empty, setting default values');
      
      const defaultStoryId = 'default-story-1';
      const defaultStoryName = 'Lock critical fields for charged-off accounts';
      const defaultStoryDescription = 'As a system architect, I want to identify and classify the necessary data fields for charged-off accounts so that we can ensure only required and relevant data is transmitted securely.';
      
      if (storyIdField) storyIdField.value = defaultStoryId;
      if (storyNameField) storyNameField.value = defaultStoryName;
      if (storyDescField) storyDescField.value = defaultStoryDescription;
      
      console.log('Default values set:', {
        id: defaultStoryId,
        name: defaultStoryName,
        description: defaultStoryDescription.substring(0, 50) + '...'
      });
    } else {
      console.log('✅ Form fields already have values, proceeding with current values');
    }
    
    // Show loading spinner and start timer
    let timerInterval = null;
    if (proceedBtn && proceedSpinner && proceedTimerEl) {
      timerInterval = showButtonLoading(proceedBtn, proceedSpinner, proceedTimerEl, 'Proceed To Selection', 'Processing...');
    } else {
      console.warn('Some proceed button elements not found');
      if (proceedBtn) {
        proceedBtn.disabled = true;
        proceedBtn.innerHTML = `
          <span style="display: inline-block; width: 1rem; height: 1rem; border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid white; border-radius: 50%; animation: spin 1s linear infinite;"></span>
          <span style="margin-left: 8px;">Processing...</span>
        `;
      }
    }

    try {
      // Get the form and create FormData
      const form = document.getElementById('proceed-form');
      if (!form) {
        console.error('CRITICAL ERROR: Proceed form not found!');
        alert('Form not found. Please refresh the page and try again.');
        return;
      }
      
      // Use FormData to submit the form
      const formData = new FormData(form);

      // Debug: Check form field values right before submission
      console.log('FINAL FORM VALIDATION BEFORE SUBMISSION');
      let hasStoryName = false;
      for (let [key, value] of formData.entries()) {
        const displayValue = value.length > 100 ? value.substring(0, 97) + '...' : value;
        console.log(`  - ${key}: "${displayValue}"`);
        if (key === 'selected_story_name' && value && value.trim() !== '') {
          hasStoryName = true;
          console.log(`✅ STORY NAME FOUND IN FORM DATA: "${value}"`);
        }
      }
      
      if (!hasStoryName) {
        console.error('❌ CRITICAL ERROR: NO STORY NAME IN FORM DATA!');
      }

      const response = await fetch("/user-story-details", {
        method: "POST",
        body: formData,
      });

      if (response.ok) {
        const html = await response.text();
        document.open();
        document.write(html);
        document.close();
        console.log('Successfully loaded user story details page.');
      } else {
        console.error('Error submitting user story selection:', response.status, response.statusText);
        const errorText = await response.text();
        console.error('Server error response:', errorText);
        alert(`Error processing user story selection. Status: ${response.status}. Please check the console for details.`);
      }

    } catch (error) {
      console.error('Error submitting user story selection:', error);
      alert('Network error. Please check your connection and try again.');
    } finally {
      // Hide loading spinner and timer
      if (proceedBtn && proceedSpinner && proceedTimerEl && timerInterval) {
        hideButtonLoading(proceedBtn, proceedSpinner, proceedTimerEl, 'Proceed To Selection', timerInterval);
      } else if (proceedBtn) {
        proceedBtn.disabled = false;
        proceedBtn.innerHTML = `
          <span class="btn-spinner" id="proceedSpinner" style="display: none;"></span>
          <span class="btn-text">Proceed To Selection</span>
          <span class="btn-timer" id="proceedTimer"></span>
        `;
      }
    }
  });

  // Placeholder functions for chat functionality
  function openEpicChat() {
    console.log('Epic chat functionality not implemented in this fixed version');
  }

  function openUserStoryChat() {
    console.log('User story chat functionality not implemented in this fixed version');
  }

  // Global function to forcibly disconnect the mutation observer
  window.forceDisconnectUserStoriesObserver = function() {
    if (window.userStoriesMutationObserver) {
      window.userStoriesMutationObserver.disconnect();
      console.log('🚫 MUTATION OBSERVER FORCIBLY DISCONNECTED BY GLOBAL FUNCTION');
      window.userStoriesMutationObserver = null;
    }
    // Also set permanent flags
    window.userStoriesParsed = true;
    userStoriesParsed = true;
  };

  // Global function to prevent any future parsing attempts
  window.lockUserStoriesParsing = function() {
    window.userStoriesParsed = true;
    userStoriesParsed = true;
    window.forceDisconnectUserStoriesObserver();
    console.log('🔐 USER STORIES PARSING PERMANENTLY LOCKED');
  };
</script>

</body>
</html>
